---
import Layout from '../layouts/Layout.astro';
import LoginForm from '../components/LoginForm.astro';
import ChatInterface from '../components/ChatInterface.astro';
import EditorInterface from '../components/EditorInterface.astro';
---

<Layout title="GCO PKM Assistant">
  <LoginForm />

  <!-- App Container -->
  <div id="app-container" class="hidden h-screen flex flex-col overflow-hidden">
    <!-- Unified Header - Always visible at top -->
    <div class="bg-blue-500 text-white px-2 sm:px-4 py-2 sm:py-3 shadow-md flex items-center gap-2 sm:gap-4 flex-shrink-0 sticky top-0 z-10">
      <!-- Title: Short on mobile, full on desktop -->
      <h1 class="text-lg sm:text-xl font-semibold whitespace-nowrap">
        <span class="sm:hidden">GCO PKM</span>
        <span class="hidden sm:inline">GCO PKM Assistant</span>
      </h1>

      <!-- Tab buttons -->
      <div class="flex gap-1 sm:gap-2">
        <button
          id="chat-tab"
          class="px-2 sm:px-3 py-1 sm:py-1.5 bg-white/20 rounded text-xs sm:text-sm"
          onclick="switchTab('chat')"
        >
          Chat
        </button>
        <button
          id="editor-tab"
          class="px-2 sm:px-3 py-1 sm:py-1.5 bg-white/0 rounded text-xs sm:text-sm"
          onclick="switchTab('editor')"
        >
          Editor
        </button>
      </div>

      <!-- Right side content -->
      <div class="ml-auto flex items-center gap-2 sm:gap-4">
        <!-- SSE connection status indicator -->
        <div
          id="sse-status"
          class="w-2 h-2 sm:w-2.5 sm:h-2.5 rounded-full bg-gray-400 transition-colors duration-300"
          title="Connecting..."
        ></div>

        <!-- Editor buttons (shown only when in editor tab) -->
        <div id="editor-header-status" class="hidden items-center gap-1 sm:gap-2">
          <button
            id="save-button"
            class="px-2 sm:px-4 py-1 sm:py-1.5 bg-white text-blue-600 rounded text-xs sm:text-sm hover:bg-gray-100 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Save
          </button>
          <button
            id="refresh-button"
            class="p-1 sm:p-1.5 bg-white/10 hover:bg-white/20 text-white rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            title="Reload file from server"
          >
            <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 10C21 10 18.995 7.26822 17.3662 5.63824C15.7373 4.00827 13.4864 3 11 3C6.02944 3 2 7.02944 2 12C2 16.9706 6.02944 21 11 21C15.1031 21 18.5649 18.2543 19.6482 14.5M21 10V4M21 10H15"/>
            </svg>
          </button>
        </div>

        <!-- Admin Link -->
        <a href="/admin" class="p-1.5 sm:p-2 bg-white/10 hover:bg-white/20 rounded-lg transition-colors" title="Admin">
          <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
          </svg>
        </a>
        <!-- Settings Link -->
        <a href="/settings" class="p-1.5 sm:p-2 bg-white/10 hover:bg-white/20 rounded-lg transition-colors" title="Settings">
          <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
        </a>
      </div>
    </div>

    <!-- Status Bar (for editor status messages) -->
    <div id="status-bar" class="hidden bg-gray-100 border-b border-gray-200 px-2 py-1 text-xs text-gray-600 flex-shrink-0">
      <span id="editor-status"></span>
    </div>

    <!-- Content Area -->
    <div class="flex-1 overflow-hidden">
      <ChatInterface />
      <EditorInterface />
    </div>
  </div>

  <!-- Session History Modal -->
  <div id="session-history-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target === this) hideSessionHistory()">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] flex flex-col">
      <div class="px-6 py-4 border-b flex justify-between items-center">
        <h2 class="text-xl font-semibold text-gray-800">Session History</h2>
        <button onclick="hideSessionHistory()" class="text-gray-500 hover:text-gray-700">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div id="session-list" class="flex-1 overflow-y-auto p-4">
        <div class="text-center text-gray-500 py-8">Loading sessions...</div>
      </div>
    </div>
  </div>
</Layout>

<script>
  import { VoiceInput, type VoiceStatus } from '../utils/VoiceInput';

  // Initialize markdown-it with task-lists plugin
  const md = (window as any).markdownit({
    html: false,
    linkify: true,
    typographer: true
  }).use((window as any).markdownitTaskLists, {enabled: true});

  // Post-process HTML to convert "DONE" items to checked checkboxes
  function processDoneItems(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;

    // Find all list items
    const listItems = div.querySelectorAll('li');

    listItems.forEach(li => {
      // Skip if already a task-list-item (handled by markdown-it-task-lists)
      if (li.classList.contains('task-list-item')) {
        return;
      }

      // Get the text content
      const text = li.textContent?.trim() || '';

      // Check if it starts with "DONE" (with : or space)
      if (text.match(/^DONE[:\s]/i)) {
        // Convert to task-list-item
        li.classList.add('task-list-item');

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-list-item-checkbox';
        checkbox.checked = true;
        checkbox.disabled = true;

        // Wrap remaining text in span with strikethrough
        const span = document.createElement('span');
        span.style.textDecoration = 'line-through';

        // Get the text without "DONE" prefix
        const remainingText = text.replace(/^DONE[:\s]\s*/i, '');
        span.textContent = remainingText;

        // Clear and rebuild the li
        li.innerHTML = '';
        li.appendChild(checkbox);
        li.appendChild(document.createTextNode(' '));
        li.appendChild(span);
      }
    });

    return div.innerHTML;
  }

  // Post-process HTML to extract checkbox metadata markers, enable interactive checkboxes
  function processCheckboxMetadata(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;

    const taskItems = div.querySelectorAll('li.task-list-item');

    taskItems.forEach(li => {
      const checkbox = li.querySelector('input.task-list-item-checkbox') as HTMLInputElement | null;
      if (!checkbox) return;

      // Walk text nodes to find metadata markers
      const walker = document.createTreeWalker(li, NodeFilter.SHOW_TEXT);
      let node: Text | null;
      let markerFound = false;

      while (node = walker.nextNode() as Text | null) {
        const text = node.textContent || '';

        // Match {ticktick:ID} pattern
        const ticktickMatch = text.match(/\{ticktick:([^}]+)\}/);
        if (ticktickMatch) {
          checkbox.dataset.checkboxType = 'ticktick';
          checkbox.dataset.checkboxId = ticktickMatch[1];
          // Remove marker from visible text
          node.textContent = text.replace(ticktickMatch[0], '').trimEnd();
          markerFound = true;
          break;
        }

        // Match {file:TYPE:PATH:LINE} pattern
        const fileMatch = text.match(/\{file:([^:}]+):([^:}]+):(\d+)\}/);
        if (fileMatch) {
          checkbox.dataset.checkboxType = 'file';
          checkbox.dataset.checkboxId = `${fileMatch[1]}:${fileMatch[2]}`;
          checkbox.dataset.lineHint = fileMatch[3];
          // Store cleaned item text for matching (text before the marker)
          const cleanText = text.replace(fileMatch[0], '').trim();
          checkbox.dataset.itemText = cleanText || li.textContent?.replace(/\{[^}]+\}/, '').trim() || '';
          // Remove marker from visible text
          node.textContent = text.replace(fileMatch[0], '').trimEnd();
          markerFound = true;
          break;
        }
      }

      if (markerFound) {
        checkbox.removeAttribute('disabled');
        checkbox.classList.add('interactive-checkbox');
      }
    });

    return div.innerHTML;
  }

  // Post-process HTML to add auth tokens to asset image URLs
  function addTokensToImages(html: string): string {
    if (!authToken) {
      return html;
    }

    const div = document.createElement('div');
    div.innerHTML = html;

    // Find all images that point to /assets/ or /api/org-attachment/
    const images = div.querySelectorAll('img[src^="http://localhost:8000/assets/"], img[src^="/assets/"], img[src^="/api/org-attachment/"], img[src^="http://localhost:8000/api/org-attachment/"]');

    images.forEach(img => {
      const src = img.getAttribute('src');
      if (src && !src.includes('?token=')) {
        // Add token as query parameter
        const separator = src.includes('?') ? '&' : '?';
        img.setAttribute('src', `${src}${separator}token=${authToken}`);
      }
    });

    return div.innerHTML;
  }

  // Pre-process markdown text to convert org-id links before markdown-it rendering.
  // Handles both [desc](org-id:UUID) and [desc](id:UUID) (Claude may use either).
  // Rewrites to [desc](#org-id:UUID) so markdown-it treats it as a fragment link.
  function preprocessOrgIdLinks(text: string): string {
    return text.replace(
      /\[([^\]]+)\]\((?:org-)?id:([A-Fa-f0-9-]+)\)/g,
      '[$1](#org-id:$2)'
    );
  }

  // Post-process HTML to make org-id links clickable
  function processOrgIdLinks(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;

    // Find links with #org-id: or bare id:/org-id: href
    const links = div.querySelectorAll('a[href^="#org-id:"], a[href^="id:"], a[href^="org-id:"]');
    links.forEach(link => {
      const href = link.getAttribute('href')!;
      const uuid = href.replace(/^#?(?:org-)?id:/, '');
      link.classList.add('org-id-link');
      link.setAttribute('data-org-id', uuid);
      link.setAttribute('href', '#');
    });

    return div.innerHTML;
  }

  // Auth token management
  let authToken = localStorage.getItem('pkm-authToken');

  // Session management
  let sessionId = localStorage.getItem('pkm-sessionId') ||
                  'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  localStorage.setItem('pkm-sessionId', sessionId);

  // Model and thinking preferences
  let selectedModel = localStorage.getItem('pkm-model') || 'claude-haiku-4-5';
  let thinkingEnabled = localStorage.getItem('pkm-thinking') === 'true';

  // DOM elements
  const loginScreen = document.getElementById('login-screen')!;
  const appDiv = document.getElementById('app')!;
  const passwordInput = document.getElementById('password-input') as HTMLInputElement;
  const loginBtn = document.getElementById('login-btn') as HTMLButtonElement;
  const loginError = document.getElementById('login-error')!;
  const chat = document.getElementById('chat')!;
  const input = document.getElementById('input') as HTMLInputElement;
  const sendBtn = document.getElementById('send-btn') as HTMLButtonElement;
  const loading = document.getElementById('loading')!;
  const emptyState = document.getElementById('empty-state')!;
  const modelSelect = document.getElementById('model-select') as HTMLSelectElement;
  const thinkingToggle = document.getElementById('thinking-toggle') as HTMLInputElement;

  // Voice input
  let voiceInput: VoiceInput | null = null;
  let isVoiceMessage = false;  // Track if current message is from voice

  // Fetch with timeout to prevent hanging on poor connectivity
  function fetchWithTimeout(url: string, options: RequestInit = {}, timeoutMs: number = 10000): Promise<Response> {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);

    return fetch(url, { ...options, signal: controller.signal })
      .finally(() => clearTimeout(timeout));
  }

  // Handle login
  async function handleLogin(event: Event) {
    event.preventDefault();
    const password = passwordInput.value;

    loginBtn.disabled = true;
    loginError.classList.add('hidden');

    try {
      const res = await fetchWithTimeout('/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({password})
      }, 10000);

      const data = await res.json();

      if (res.ok) {
        authToken = data.token;
        localStorage.setItem('pkm-authToken', authToken);
        showApp();
      } else {
        loginError.textContent = data.error || 'Invalid password';
        loginError.classList.remove('hidden');
        passwordInput.value = '';
        passwordInput.focus();
      }
    } catch (e: any) {
      loginError.textContent = 'Connection error: ' + e.message;
      loginError.classList.remove('hidden');
    } finally {
      loginBtn.disabled = false;
    }
  }

  // Initialize voice input
  function initializeVoiceInput() {
    const voiceBtn = document.getElementById('voice-btn') as HTMLButtonElement;
    const voiceStatus = document.getElementById('voice-status') as HTMLDivElement;
    const voiceStatusText = document.getElementById('voice-status-text') as HTMLSpanElement;

    if (!voiceBtn || !voiceStatus || !voiceStatusText) {
      console.warn('Voice input elements not found');
      return;
    }

    voiceInput = new VoiceInput({
      language: 'en',
      getAuthHeaders: () => getAuthHeaders(),

      onTranscript: (text: string) => {
        // Append transcribed text to input
        const existing = input.value.trim();
        input.value = existing ? existing + ' ' + text : text;
        autoResizeTextarea();
        isVoiceMessage = true;
      },

      onStart: () => {
        voiceBtn.classList.add('recording');
        voiceBtn.title = 'Tap to stop recording';
        voiceStatus.classList.remove('hidden');
        voiceStatusText.textContent = 'Listening...';
      },

      onEnd: () => {
        voiceBtn.classList.remove('recording');
        voiceBtn.title = 'Tap to start voice input';

        if (input.value.trim()) {
          voiceStatusText.textContent = 'Voice input complete. Press Send when ready.';
          setTimeout(() => voiceStatus.classList.add('hidden'), 3000);
        } else {
          setTimeout(() => voiceStatus.classList.add('hidden'), 2000);
        }
      },

      onStatusChange: (status: VoiceStatus) => {
        if (status === 'listening') {
          voiceStatusText.textContent = 'Listening...';
        } else if (status === 'transcribing') {
          voiceStatusText.textContent = 'Transcribing...';
        }
      },

      onError: (error: string) => {
        voiceBtn.classList.remove('recording');
        voiceStatusText.textContent = error;
        voiceStatus.classList.remove('bg-blue-50', 'border-blue-200', 'text-blue-700');
        voiceStatus.classList.add('bg-red-50', 'border-red-200', 'text-red-700');
        setTimeout(() => {
          voiceStatus.classList.add('hidden');
          voiceStatus.classList.add('bg-blue-50', 'border-blue-200', 'text-blue-700');
          voiceStatus.classList.remove('bg-red-50', 'border-red-200', 'text-red-700');
        }, 3000);
      }
    });

    // Check browser support
    if (!voiceInput.isSupported()) {
      voiceBtn.disabled = true;
      voiceBtn.classList.add('disabled');
      voiceBtn.title = 'Voice input not supported in this browser';
      return;
    }

    // Long-press mic button to clear text input
    let longPressTimer: ReturnType<typeof setTimeout> | null = null;
    let didLongPress = false;

    function startLongPress() {
      didLongPress = false;
      longPressTimer = setTimeout(async () => {
        didLongPress = true;
        // Stop mic if active
        if (voiceInput?.isActive()) {
          await voiceInput.stop();
        }
        input.value = '';
        autoResizeTextarea();
        isVoiceMessage = false;
        // Brief "Cleared" feedback
        voiceStatusText.textContent = 'Cleared';
        voiceStatus.classList.remove('hidden');
        setTimeout(() => voiceStatus.classList.add('hidden'), 800);
      }, 700);
    }

    function cancelLongPress() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }

    voiceBtn.addEventListener('pointerdown', startLongPress);
    voiceBtn.addEventListener('pointerup', cancelLongPress);
    voiceBtn.addEventListener('pointerleave', cancelLongPress);
    voiceBtn.addEventListener('pointercancel', cancelLongPress);

    // Click handler -- skip if long-press already fired
    voiceBtn.addEventListener('click', async (e) => {
      if (!voiceInput) return;
      if (didLongPress) {
        didLongPress = false;
        return;
      }
      await voiceInput.toggle();
    });

    // Stop mic when user manually edits text (programmatic .value changes don't fire 'input')
    input.addEventListener('input', () => {
      if (voiceInput?.isActive()) {
        voiceInput.stop();
      }
    });
  }

  // Show app (hide login)
  function showApp() {
    loginScreen.classList.add('hidden');

    const appContainer = document.getElementById('app-container');
    if (appContainer) {
      appContainer.classList.remove('hidden');
    }

    // Initialize UI controls from saved preferences
    modelSelect.value = selectedModel;
    thinkingToggle.checked = thinkingEnabled;
    updateModelButtonHighlight();

    // Always start on chat tab
    switchTab('chat');

    loadHistory();
    initializeVoiceInput();
  }

  // Show login (hide app)
  function showLogin() {
    loginScreen.classList.remove('hidden');

    const appContainer = document.getElementById('app-container');
    if (appContainer) {
      appContainer.classList.add('hidden');
    }

    passwordInput.value = '';
    passwordInput.focus();
  }

  // Logout
  function logout() {
    authToken = null;
    localStorage.removeItem('pkm-authToken');
    showLogin();
  }

  // Switch between tabs
  function switchTab(tab: 'chat' | 'editor') {
    const chatApp = document.getElementById('app');
    const editorApp = document.getElementById('editor-app');
    const chatTab = document.getElementById('chat-tab');
    const editorTab = document.getElementById('editor-tab');
    const editorHeaderStatus = document.getElementById('editor-header-status');
    const statusBar = document.getElementById('status-bar');

    if (tab === 'chat') {
      chatApp?.classList.remove('hidden');
      editorApp?.classList.add('hidden');
      editorHeaderStatus?.classList.add('hidden');
      editorHeaderStatus?.classList.remove('flex');
      statusBar?.classList.add('hidden');

      chatTab?.classList.remove('bg-white/0');
      chatTab?.classList.add('bg-white/20');
      editorTab?.classList.remove('bg-white/20');
      editorTab?.classList.add('bg-white/0');

      // Clean up editor timers when switching away
      const cleanup = (window as any).cleanupAutoSaveTimers;
      if (cleanup) cleanup();

      // Scroll chat to bottom when switching to it
      setTimeout(() => {
        const chatDiv = document.getElementById('chat');
        if (chatDiv) {
          chatDiv.scrollTop = chatDiv.scrollHeight;
        }
      }, 0);

      input.focus();
    } else {
      chatApp?.classList.add('hidden');
      editorApp?.classList.remove('hidden');
      editorHeaderStatus?.classList.remove('hidden');
      editorHeaderStatus?.classList.add('flex');
      statusBar?.classList.remove('hidden');

      editorTab?.classList.remove('bg-white/0');
      editorTab?.classList.add('bg-white/20');
      chatTab?.classList.remove('bg-white/20');
      chatTab?.classList.add('bg-white/0');

      // Refresh auto-save settings when switching to editor
      // (in case user changed settings in settings page via same tab navigation)
      const refresh = (window as any).refreshAutoSaveSettings;
      if (refresh) refresh();
    }

    // Save current tab preference
    localStorage.setItem('pkm-currentTab', tab);
  }

  // Update model button styling based on cost
  function updateModelButtonHighlight() {
    const modelBtn = document.getElementById('model-settings-btn');
    if (!modelBtn) return;

    // Highlight if using non-Haiku model or extended thinking
    const isExpensive = selectedModel !== 'claude-haiku-4-5' || thinkingEnabled;

    if (isExpensive) {
      modelBtn.classList.remove('bg-gray-100', 'hover:bg-gray-200', 'text-gray-700');
      modelBtn.classList.add('bg-yellow-400', 'hover:bg-yellow-500', 'text-gray-900');
    } else {
      modelBtn.classList.remove('bg-yellow-400', 'hover:bg-yellow-500', 'text-gray-900');
      modelBtn.classList.add('bg-gray-100', 'hover:bg-gray-200', 'text-gray-700');
    }
  }

  // Update model selection
  function updateModel() {
    selectedModel = modelSelect.value;
    localStorage.setItem('pkm-model', selectedModel);
    console.log('Model changed to:', selectedModel);
    updateModelButtonHighlight();
  }

  // Update thinking toggle
  function updateThinking() {
    thinkingEnabled = thinkingToggle.checked;
    localStorage.setItem('pkm-thinking', thinkingEnabled.toString());
    console.log('Deep thinking:', thinkingEnabled);
    updateModelButtonHighlight();
  }

  // Verify token on page load
  async function verifyToken() {
    if (!authToken) {
      showLogin();
      return;
    }

    try {
      const res = await fetchWithTimeout('/verify-token', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({token: authToken})
      }, 10000);

      const data = await res.json();

      if (data.valid) {
        showApp();
      } else {
        authToken = null;
        localStorage.removeItem('pkm-authToken');
        showLogin();
      }
    } catch (e) {
      console.error('Token verification error:', e);
      showLogin();
    }
  }

  // Get auth headers
  function getAuthHeaders(): HeadersInit {
    const headers: HeadersInit = {'Content-Type': 'application/json'};
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }
    return headers;
  }

  // Handle 401 errors
  function handle401() {
    authToken = null;
    localStorage.removeItem('pkm-authToken');
    showLogin();
    alert('Your session has expired. Please log in again.');
  }

  // Send message
  async function send() {
    // Stop voice recording if still active
    if (voiceInput && voiceInput.isActive()) {
      await voiceInput.stop();
    }

    // Hide voice status bar
    const voiceStatus = document.getElementById('voice-status');
    if (voiceStatus) {
      voiceStatus.classList.add('hidden');
    }

    const message = input.value.trim();
    if (!message) return;

    input.value = '';
    input.style.height = 'auto'; // Reset textarea height
    input.disabled = true;
    sendBtn.disabled = true;

    emptyState.style.display = 'none';

    appendMessage('user', message);

    loading.classList.remove('hidden');
    loading.classList.add('flex');
    chat.scrollTop = chat.scrollHeight;

    try {
      // Get user's timezone from browser
      const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

      const requestBody: any = {
        message: message,
        session_id: sessionId,
        model: selectedModel,
        timezone: userTimezone,
        is_voice: isVoiceMessage  // Add voice flag
      };

      if (thinkingEnabled) {
        requestBody.thinking = { type: 'enabled', budget_tokens: 10000 };
      }

      // Reset voice flag after using it
      isVoiceMessage = false;

      const res = await fetchWithTimeout('/query', {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify(requestBody)
      }, 60000); // 60s timeout for streaming queries

      if (res.status === 401) {
        handle401();
        return;
      }

      const data = await res.json();

      loading.classList.add('hidden');
      loading.classList.remove('flex');

      appendMessage('assistant', data.response, data.query_id);

      // Auto-update Activity panel if it's open
      const toolLogsPanel = document.getElementById('tool-logs-panel');
      if (toolLogsPanel && !toolLogsPanel.classList.contains('hidden')) {
        loadToolLogs();
      }

      // Update cost warning if > $1.00
      if (data.session_cost && data.session_cost > 1.0) {
        const costWarning = document.getElementById('cost-warning');
        const costAmount = document.getElementById('cost-amount');
        if (costWarning && costAmount) {
          costAmount.textContent = `$${data.session_cost.toFixed(2)}`;
          costWarning.classList.remove('hidden');
        }
      }
    } catch (e: any) {
      loading.classList.add('hidden');
      loading.classList.remove('flex');

      if (e.name === 'AbortError') {
        // Query timed out - verify if it completed on server
        // Skip verification if offline - recovery will be faster
        if (!navigator.onLine) {
          appendMessage('assistant', '❌ Query timed out (offline)');
          return;
        }

        appendMessage('assistant', '⏱️ Response timed out, checking server...');

        try {
          // Count messages before reload
          const messagesBefore = chat.querySelectorAll('.message').length;

          // Reload history to sync with server state
          // Use short timeout to fail fast if network is still down
          const res = await fetchWithTimeout(`/sessions/${sessionId}/history`, {
            headers: getAuthHeaders()
          }, 3000);

          if (res.ok) {
            const history = await res.json();

            // Check if there are new messages (query completed on server)
            if (history.length > messagesBefore) {
              // Clear chat and reload all history
              const messages = chat.querySelectorAll('.message');
              messages.forEach(msg => msg.remove());

              history.forEach((msg: any) => appendMessage(msg.role, msg.text));

              // Remove the timeout message and show success
              const timeoutMsg = chat.querySelector('.message.assistant:last-child');
              if (timeoutMsg && timeoutMsg.textContent?.includes('timed out')) {
                timeoutMsg.remove();
              }
              appendMessage('assistant', 'ℹ️ Response received (connection was slow)');
            } else {
              // Query truly failed - update timeout message
              const timeoutMsg = chat.querySelector('.message.assistant:last-child');
              if (timeoutMsg) {
                timeoutMsg.textContent = '❌ Query timed out and did not complete on server';
              }
            }
          } else {
            // Couldn't verify - show warning
            const timeoutMsg = chat.querySelector('.message.assistant:last-child');
            if (timeoutMsg) {
              timeoutMsg.textContent = '⚠️ Query timed out. Could not verify server state.';
            }
          }
        } catch (verifyError) {
          console.error('Failed to verify query completion:', verifyError);
          const timeoutMsg = chat.querySelector('.message.assistant:last-child');
          if (timeoutMsg) {
            timeoutMsg.textContent = '⚠️ Query timed out. Could not verify server state.';
          }
        }
      } else {
        appendMessage('assistant', '❌ Error: ' + e.message);
      }
    } finally {
      input.disabled = false;
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Send example query
  function sendExample(text: string) {
    input.value = text;
    send();
  }

  // Append message to chat
  function appendMessage(role: string, text: string, queryId?: string) {
    const div = document.createElement('div');
    div.className = `message ${role}`;

    if (role === 'assistant') {
      let rendered = md.render(preprocessOrgIdLinks(text));
      rendered = processDoneItems(rendered);
      rendered = processCheckboxMetadata(rendered);
      rendered = addTokensToImages(rendered);
      rendered = processOrgIdLinks(rendered);
      div.innerHTML = rendered;

      // Add feedback bar for assistant messages with a query_id
      if (queryId) {
        const feedbackBar = document.createElement('div');
        feedbackBar.className = 'feedback-bar';
        feedbackBar.dataset.queryId = queryId;
        feedbackBar.innerHTML = `
          <button class="feedback-btn thumbs-up" title="Good response">&#128077;</button>
          <button class="feedback-btn thumbs-down" title="Bad response">&#128078;</button>
        `;
        div.appendChild(feedbackBar);
      }
    } else {
      div.textContent = text;
    }

    chat.insertBefore(div, loading);
    chat.scrollTop = chat.scrollHeight;
  }

  // Handle interactive checkbox clicks via event delegation
  chat.addEventListener('change', async (e) => {
    const target = e.target as HTMLInputElement;
    if (!target.classList.contains('interactive-checkbox')) return;

    const checkboxType = target.dataset.checkboxType;
    const checkboxId = target.dataset.checkboxId;
    const isChecked = target.checked;

    // Prevent double-clicks
    target.classList.add('checkbox-toggling');

    // Build request body
    let body: any;
    if (checkboxType === 'ticktick') {
      body = { type: 'ticktick', task_id: checkboxId, checked: isChecked };
    } else if (checkboxType === 'file') {
      body = {
        type: 'file',
        path: checkboxId,
        item_text: target.dataset.itemText || '',
        line_hint: parseInt(target.dataset.lineHint || '0', 10),
        checked: isChecked
      };
    } else {
      return;
    }

    try {
      const res = await fetchWithTimeout('/api/checkbox/toggle', {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify(body)
      }, 10000);

      if (res.status === 401) {
        handle401();
        target.checked = !isChecked;
        return;
      }

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || 'Toggle failed');
      }

      // Success: apply strikethrough for checked items
      const li = target.closest('li');
      if (li) {
        if (isChecked) {
          // Wrap text content in strikethrough span if not already
          const textNodes = Array.from(li.childNodes).filter(n => n.nodeType === Node.TEXT_NODE || (n.nodeType === Node.ELEMENT_NODE && !(n as Element).matches('input')));
          textNodes.forEach(n => {
            if (n.nodeType === Node.ELEMENT_NODE) {
              (n as HTMLElement).style.textDecoration = 'line-through';
              (n as HTMLElement).style.color = 'rgb(107 114 128)';
            }
          });
        } else {
          // Remove strikethrough
          const styled = li.querySelectorAll('[style*="line-through"]');
          styled.forEach(el => {
            (el as HTMLElement).style.textDecoration = '';
            (el as HTMLElement).style.color = '';
          });
        }
      }
    } catch (err: any) {
      console.error('Checkbox toggle failed:', err);
      // Revert checkbox state
      target.checked = !isChecked;
      // Flash error
      target.classList.add('checkbox-error');
      setTimeout(() => target.classList.remove('checkbox-error'), 1500);
    } finally {
      target.classList.remove('checkbox-toggling');
    }
  });

  // Handle feedback button clicks via event delegation
  chat.addEventListener('click', async (e) => {
    const target = e.target as HTMLElement;
    if (!target.classList.contains('feedback-btn')) return;

    const feedbackBar = target.closest('.feedback-bar') as HTMLElement;
    if (!feedbackBar) return;

    const queryId = feedbackBar.dataset.queryId;
    if (!queryId) return;

    const isPositive = target.classList.contains('thumbs-up');
    const feedback = isPositive ? 'positive' : 'negative';

    // For negative feedback, prompt for optional note
    let note: string | null = null;
    if (!isPositive) {
      note = prompt('What was wrong with this response? (optional)');
    }

    // Disable buttons and highlight selected
    const buttons = feedbackBar.querySelectorAll('.feedback-btn');
    buttons.forEach(btn => {
      (btn as HTMLButtonElement).disabled = true;
      btn.classList.add('feedback-submitted');
    });
    target.classList.add('feedback-selected');

    try {
      await fetchWithTimeout('/api/feedback', {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ query_id: queryId, feedback, note })
      }, 10000);
    } catch (err) {
      console.error('Failed to submit feedback:', err);
      // Re-enable on error
      buttons.forEach(btn => {
        (btn as HTMLButtonElement).disabled = false;
        btn.classList.remove('feedback-submitted');
      });
      target.classList.remove('feedback-selected');
    }
  });

  // Handle org-id link clicks (event delegation)
  chat.addEventListener('click', async (e) => {
    const target = (e.target as HTMLElement).closest('.org-id-link') as HTMLElement | null;
    if (!target) return;

    e.preventDefault();
    const uuid = target.dataset.orgId;
    if (!uuid) return;

    try {
      const res = await fetchWithTimeout(`/api/resolve-org-id/${encodeURIComponent(uuid)}`, {
        headers: getAuthHeaders()
      }, 10000);

      if (!res.ok) {
        console.warn('Could not resolve org-id:', uuid);
        return;
      }

      const data = await res.json();
      // Switch to editor tab and open the file
      const switchTabFn = (window as any).switchTab;
      if (switchTabFn) {
        switchTabFn('editor');
      }
      // Dispatch openFile event for EditorInterface to handle
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('openFile', {
          detail: { path: data.path, line: data.line }
        }));
      }, 150);
    } catch (err) {
      console.error('Failed to resolve org-id link:', err);
    }
  });

  // Show/hide model settings modal
  function showModelSettings() {
    const modal = document.getElementById('model-settings-modal')!;
    modal.classList.remove('hidden');
  }

  function hideModelSettings() {
    const modal = document.getElementById('model-settings-modal')!;
    modal.classList.add('hidden');
  }

  // Show session history modal
  async function showSessionHistory() {
    const modal = document.getElementById('session-history-modal')!;
    const sessionList = document.getElementById('session-list')!;

    modal.classList.remove('hidden');
    sessionList.innerHTML = '<div class="text-center text-gray-500 py-8">Loading sessions...</div>';

    try {
      const res = await fetchWithTimeout('/sessions', {
        headers: getAuthHeaders()
      }, 15000);

      if (res.status === 401) {
        handle401();
        return;
      }

      const sessions = await res.json();

      if (sessions.length === 0) {
        sessionList.innerHTML = '<div class="text-center text-gray-500 py-8">No sessions found</div>';
        return;
      }

      // Sort by updated_at descending
      sessions.sort((a: any, b: any) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());

      sessionList.innerHTML = sessions.map((session: any) => {
        const isActive = session.session_id === sessionId;
        const date = new Date(session.updated_at).toLocaleString();
        const preview = session.preview || 'Empty session';
        const cost = session.total_cost || 0;
        const costDisplay = cost > 0 ? `$${cost.toFixed(3)}` : '';

        return `
          <div class="border rounded-lg p-4 mb-3 hover:bg-gray-50 cursor-pointer ${isActive ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}"
               onclick="switchToSession('${session.session_id}')">
            <div class="flex justify-between items-start mb-2">
              <div class="text-sm text-gray-500">${date}</div>
              <div class="flex gap-2 items-center">
                ${costDisplay ? `<span class="text-xs px-2 py-1 bg-gray-200 text-gray-700 rounded">${costDisplay}</span>` : ''}
                ${isActive ? '<span class="text-xs px-2 py-1 bg-blue-500 text-white rounded">Current</span>' : ''}
              </div>
            </div>
            <div class="text-gray-800 truncate mb-1">${preview}</div>
            <div class="text-xs text-gray-500">${session.message_count} messages</div>
          </div>
        `;
      }).join('');
    } catch (e: any) {
      sessionList.innerHTML = `<div class="text-center text-red-500 py-8">Error loading sessions: ${e.message}</div>`;
    }
  }

  // Hide session history modal
  function hideSessionHistory() {
    const modal = document.getElementById('session-history-modal')!;
    modal.classList.add('hidden');
  }

  // Switch to a different session
  async function switchToSession(newSessionId: string) {
    if (newSessionId === sessionId) {
      hideSessionHistory();
      return;
    }

    sessionId = newSessionId;
    localStorage.setItem('pkm-sessionId', sessionId);

    // Hide cost warning for new session
    const costWarning = document.getElementById('cost-warning');
    if (costWarning) {
      costWarning.classList.add('hidden');
    }

    // Clear current chat
    const messages = chat.querySelectorAll('.message');
    messages.forEach(msg => msg.remove());

    // Load new session history
    await loadHistory();

    // Reconnect SSE with new session ID
    const reconnectSSE = (window as any).reconnectSSEForNewSession;
    if (reconnectSSE) reconnectSSE();

    hideSessionHistory();
    console.log('Switched to session:', sessionId);
  }

  // Start new session
  function newSession() {
    sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem('pkm-sessionId', sessionId);

    const messages = chat.querySelectorAll('.message');
    messages.forEach(msg => msg.remove());

    emptyState.style.display = 'block';

    // Reconnect SSE with new session ID
    const reconnectSSE = (window as any).reconnectSSEForNewSession;
    if (reconnectSSE) reconnectSSE();

    console.log('New session started:', sessionId);
  }

  // Load conversation history
  async function loadHistory() {
    try {
      const res = await fetchWithTimeout(`/sessions/${sessionId}/history`, {
        headers: getAuthHeaders()
      }, 15000);

      if (res.status === 401) {
        handle401();
        return;
      }

      const history = await res.json();

      if (history.length > 0) {
        emptyState.style.display = 'none';
        history.forEach((msg: any) => appendMessage(msg.role, msg.text));
      }
    } catch (e) {
      console.error('Error loading history:', e);
    }
  }

  // Auto-resize textarea as user types, up to its max-height
  function autoResizeTextarea() {
    input.style.height = 'auto';
    const maxHeight = parseInt(getComputedStyle(input).maxHeight, 10) || 240;
    input.style.height = Math.min(input.scrollHeight, maxHeight) + 'px';
  }

  input.addEventListener('input', () => {
    autoResizeTextarea();
  });

  // Keyboard shortcuts
  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      input.focus();
    }
  });

  // Set up login form handler
  document.getElementById('login-form')?.addEventListener('submit', handleLogin);

  // Swipe gesture handling for mobile tab switching
  let touchStartX = 0;
  let touchStartY = 0;
  let touchEndX = 0;
  let touchEndY = 0;
  let touchStartElement: HTMLElement | null = null;

  function isSwipeableArea(element: HTMLElement | null): boolean {
    if (!element) return false;

    // Check if touch started in chat messages area
    const chatArea = document.getElementById('chat');
    if (chatArea && chatArea.contains(element)) {
      return true;
    }

    // Check if touch started in editor file selector area (top bar of editor)
    const editorFileSelector = element.closest('.bg-gray-50.px-4.py-3.border-b');
    if (editorFileSelector) {
      return true;
    }

    // Check if touch is in the header area
    const header = element.closest('.bg-blue-500.text-white');
    if (header) {
      return true;
    }

    return false;
  }

  function handleSwipeGesture() {
    // Only handle swipes that started in swipeable areas
    if (!isSwipeableArea(touchStartElement)) {
      return;
    }

    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;

    // Only handle horizontal swipes (more horizontal than vertical)
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      const minSwipeDistance = 50; // minimum distance for swipe

      if (deltaX < -minSwipeDistance) {
        // Swipe left - go to editor
        switchTab('editor');
      } else if (deltaX > minSwipeDistance) {
        // Swipe right - go to chat
        switchTab('chat');
      }
    }
  }

  // Add touch listeners to content area
  const contentArea = document.querySelector('#app-container');
  if (contentArea) {
    contentArea.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
      touchStartElement = e.target as HTMLElement;
    }, { passive: true });

    contentArea.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      handleSwipeGesture();
      touchStartElement = null;
    }, { passive: true });
  }

  // Verify token and load app on page load
  verifyToken();

  // Tool logs functions
  function toggleToolLogs() {
    const panel = document.getElementById('tool-logs-panel');
    const btn = document.getElementById('tool-logs-btn');

    if (panel && btn) {
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        btn.classList.add('bg-blue-100', 'border-blue-300');
        loadToolLogs();
      } else {
        panel.classList.add('hidden');
        btn.classList.remove('bg-blue-100', 'border-blue-300');
      }
    }
  }

  async function loadToolLogs() {
    const content = document.getElementById('tool-logs-content');
    if (!content) return;

    content.innerHTML = '<div class="text-center text-gray-500 py-4">Loading activity logs...</div>';

    try {
      const res = await fetch(`/sessions/${sessionId}/tool-logs`, {
        headers: getAuthHeaders()
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const logs = await res.json();

      if (logs.length === 0) {
        content.innerHTML = '<div class="text-center text-gray-500 py-4">No tool activity yet</div>';
        return;
      }

      // Render logs as cards
      content.innerHTML = logs.map(renderLogCard).join('');
    } catch (e: any) {
      content.innerHTML = `<div class="text-center text-red-500 py-4">Error: ${e.message}</div>`;
    }
  }

  function renderLogCard(log: any): string {
    // Find query summary (contains total time)
    const querySummary = log.tools.find((t: any) => t.tool_name === '__query_summary__');

    // Filter out summary from individual tools
    const actualTools = log.tools.filter((t: any) => t.tool_name !== '__query_summary__');

    const toolsHtml = actualTools.map((tool: any) => {
      const statusIcon = tool.exit_code === 0 || tool.exit_code === null ? '✓' : '✗';
      const statusColor = tool.exit_code === 0 || tool.exit_code === null ? 'text-green-600' : 'text-red-600';

      return `
        <div class="ml-4 mb-2 p-3 bg-white rounded border border-gray-200">
          <div class="flex items-start gap-2">
            <span class="${statusColor} font-bold">${statusIcon}</span>
            <div class="flex-1">
              <div class="font-mono text-sm text-gray-700">
                <span class="font-semibold">${tool.tool_name}</span>
              </div>
              <div class="text-xs text-gray-500 mt-1">
                ${formatToolParams(tool.tool_params)}
              </div>
              <div class="text-xs text-gray-600 mt-1">
                ${tool.result_summary}
              </div>
              <div class="text-xs text-gray-400 mt-1">
                ${tool.execution_time_ms}ms
                ${tool.exit_code !== null ? ` • Exit code: ${tool.exit_code}` : ''}
              </div>
            </div>
          </div>
        </div>
      `;
    }).join('');

    return `
      <div class="bg-white rounded-lg border border-gray-300 shadow-sm p-4">
        <div class="font-semibold text-gray-900 mb-2">${escapeHtml(log.user_message)}</div>
        <div class="flex items-center gap-2 text-xs text-gray-500 mb-3">
          <span>${formatTimestamp(log.timestamp)}</span>
          ${querySummary ? `<span>•</span><span class="font-medium">Total: ${querySummary.execution_time_ms}ms</span>` : ''}
          ${querySummary && querySummary.tool_params ? `<span>•</span><span>${querySummary.tool_params.tool_calls || 0} tool${querySummary.tool_params.tool_calls !== 1 ? 's' : ''}</span>` : ''}
        </div>
        ${actualTools.length > 0 ? toolsHtml : '<div class="text-sm text-gray-500 italic">No tools used</div>'}
      </div>
    `;
  }

  function formatToolParams(params: any): string {
    if (params.command) {
      return `Command: <code class="bg-gray-100 px-1 rounded">${escapeHtml(params.command)}</code>`;
    }
    if (params.query) {
      return `Query: <code class="bg-gray-100 px-1 rounded">${escapeHtml(params.query)}</code>`;
    }
    if (params.path) {
      return `Path: <code class="bg-gray-100 px-1 rounded">${escapeHtml(params.path)}</code>`;
    }
    // Truncate if JSON is too long
    const jsonStr = JSON.stringify(params);
    if (jsonStr.length > 100) {
      return `<code class="bg-gray-100 px-1 rounded">${escapeHtml(jsonStr.substring(0, 100))}...</code>`;
    }
    return `<code class="bg-gray-100 px-1 rounded">${escapeHtml(jsonStr)}</code>`;
  }

  function formatTimestamp(iso: string): string {
    return new Date(iso).toLocaleString();
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Handle network connectivity changes
  window.addEventListener('online', () => {
    console.log('Network back online, forcing reconnect');

    // Update UI
    const statusBar = document.getElementById('status-bar');
    const editorStatus = document.getElementById('editor-status');
    if (statusBar && !statusBar.classList.contains('hidden')) {
      if (editorStatus) {
        editorStatus.textContent = 'Network reconnected';
        editorStatus.style.color = 'inherit';
      }
    }

    // Force SSE reconnect in editor
    const reconnectSSE = (window as any).reconnectSSEForNewSession;
    if (reconnectSSE) {
      reconnectSSE();
    }
  });

  window.addEventListener('offline', () => {
    console.log('Network offline');

    // Update UI
    const statusBar = document.getElementById('status-bar');
    const editorStatus = document.getElementById('editor-status');
    if (statusBar && !statusBar.classList.contains('hidden')) {
      if (editorStatus) {
        editorStatus.textContent = 'No internet connection';
        editorStatus.style.color = '#ef4444';
      }
    }
  });

  // Make functions globally available
  (window as any).send = send;
  (window as any).sendExample = sendExample;
  (window as any).showModelSettings = showModelSettings;
  (window as any).hideModelSettings = hideModelSettings;
  (window as any).showSessionHistory = showSessionHistory;
  (window as any).hideSessionHistory = hideSessionHistory;
  (window as any).switchToSession = switchToSession;
  (window as any).newSession = newSession;
  (window as any).logout = logout;
  (window as any).updateModel = updateModel;
  (window as any).updateThinking = updateThinking;
  (window as any).switchTab = switchTab;
  (window as any).toggleToolLogs = toggleToolLogs;
  (window as any).loadToolLogs = loadToolLogs;

  // Make sessionId available globally for SSE connection
  (window as any).getSessionId = () => sessionId;
</script>

---
import Layout from '../layouts/Layout.astro';
import LoginForm from '../components/LoginForm.astro';
import ChatInterface from '../components/ChatInterface.astro';
import EditorInterface from '../components/EditorInterface.astro';
---

<Layout title="GCO PKM Assistant">
  <LoginForm />

  <!-- App Container -->
  <div id="app-container" class="hidden h-screen flex flex-col">
    <!-- Unified Header -->
    <div class="bg-blue-500 text-white px-4 py-3 shadow-md flex items-center gap-4 flex-shrink-0 min-h-[56px]">
      <h1 class="text-xl font-semibold">GCO PKM Assistant</h1>

      <!-- Tab buttons -->
      <div class="flex gap-2">
        <button
          id="chat-tab"
          class="px-3 py-1.5 bg-white/20 rounded text-sm"
          onclick="switchTab('chat')"
        >
          Chat
        </button>
        <button
          id="editor-tab"
          class="px-3 py-1.5 bg-white/0 rounded text-sm"
          onclick="switchTab('editor')"
        >
          Editor
        </button>
      </div>

      <!-- Right side content -->
      <div class="ml-auto flex items-center gap-4">
        <!-- Editor status (shown only when in editor tab) -->
        <div id="editor-header-status" class="hidden items-center gap-4">
          <span id="editor-status" class="text-sm"></span>
          <button
            id="refresh-button"
            class="px-4 py-1.5 bg-white text-gray-600 rounded-lg hover:bg-gray-100 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
            title="Reload file from server"
          >
            Refresh
          </button>
          <button
            id="save-button"
            class="px-4 py-1.5 bg-white text-blue-600 rounded-lg hover:bg-gray-100 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Save
          </button>
        </div>

        <!-- Settings Link -->
        <a href="/settings" class="px-3 py-1.5 bg-white/10 hover:bg-white/20 rounded text-sm transition-colors">
          ⚙️ Settings
        </a>
      </div>
    </div>

    <!-- Content Area -->
    <div class="flex-1 overflow-hidden">
      <ChatInterface />
      <EditorInterface />
    </div>
  </div>

  <!-- Session History Modal -->
  <div id="session-history-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target === this) hideSessionHistory()">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] flex flex-col">
      <div class="px-6 py-4 border-b flex justify-between items-center">
        <h2 class="text-xl font-semibold text-gray-800">Session History</h2>
        <button onclick="hideSessionHistory()" class="text-gray-500 hover:text-gray-700">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div id="session-list" class="flex-1 overflow-y-auto p-4">
        <div class="text-center text-gray-500 py-8">Loading sessions...</div>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Initialize markdown-it with task-lists plugin
  const md = (window as any).markdownit({
    html: false,
    linkify: true,
    typographer: true
  }).use((window as any).markdownitTaskLists, {enabled: true});

  // Post-process HTML to convert "DONE" items to checked checkboxes
  function processDoneItems(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;

    // Find all list items
    const listItems = div.querySelectorAll('li');

    listItems.forEach(li => {
      // Skip if already a task-list-item (handled by markdown-it-task-lists)
      if (li.classList.contains('task-list-item')) {
        return;
      }

      // Get the text content
      const text = li.textContent?.trim() || '';

      // Check if it starts with "DONE" (with : or space)
      if (text.match(/^DONE[:\s]/i)) {
        // Convert to task-list-item
        li.classList.add('task-list-item');

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-list-item-checkbox';
        checkbox.checked = true;
        checkbox.disabled = true;

        // Wrap remaining text in span with strikethrough
        const span = document.createElement('span');
        span.style.textDecoration = 'line-through';

        // Get the text without "DONE" prefix
        const remainingText = text.replace(/^DONE[:\s]\s*/i, '');
        span.textContent = remainingText;

        // Clear and rebuild the li
        li.innerHTML = '';
        li.appendChild(checkbox);
        li.appendChild(document.createTextNode(' '));
        li.appendChild(span);
      }
    });

    return div.innerHTML;
  }

  // Post-process HTML to add auth tokens to asset image URLs
  function addTokensToImages(html: string): string {
    if (!authToken) {
      return html;
    }

    const div = document.createElement('div');
    div.innerHTML = html;

    // Find all images that point to /assets/
    const images = div.querySelectorAll('img[src^="http://localhost:8000/assets/"], img[src^="/assets/"]');

    images.forEach(img => {
      const src = img.getAttribute('src');
      if (src && !src.includes('?token=')) {
        // Add token as query parameter
        const separator = src.includes('?') ? '&' : '?';
        img.setAttribute('src', `${src}${separator}token=${authToken}`);
      }
    });

    return div.innerHTML;
  }

  // Auth token management
  let authToken = localStorage.getItem('pkm-authToken');

  // Session management
  let sessionId = localStorage.getItem('pkm-sessionId') ||
                  'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  localStorage.setItem('pkm-sessionId', sessionId);

  // Model and thinking preferences
  let selectedModel = localStorage.getItem('pkm-model') || 'claude-haiku-4-5';
  let thinkingEnabled = localStorage.getItem('pkm-thinking') === 'true';

  // DOM elements
  const loginScreen = document.getElementById('login-screen')!;
  const appDiv = document.getElementById('app')!;
  const passwordInput = document.getElementById('password-input') as HTMLInputElement;
  const loginBtn = document.getElementById('login-btn') as HTMLButtonElement;
  const loginError = document.getElementById('login-error')!;
  const chat = document.getElementById('chat')!;
  const input = document.getElementById('input') as HTMLInputElement;
  const sendBtn = document.getElementById('send-btn') as HTMLButtonElement;
  const loading = document.getElementById('loading')!;
  const emptyState = document.getElementById('empty-state')!;
  const modelSelect = document.getElementById('model-select') as HTMLSelectElement;
  const thinkingToggle = document.getElementById('thinking-toggle') as HTMLInputElement;

  // Handle login
  async function handleLogin(event: Event) {
    event.preventDefault();
    const password = passwordInput.value;

    loginBtn.disabled = true;
    loginError.classList.add('hidden');

    try {
      const res = await fetch('/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({password})
      });

      const data = await res.json();

      if (res.ok) {
        authToken = data.token;
        localStorage.setItem('pkm-authToken', authToken);
        showApp();
      } else {
        loginError.textContent = data.error || 'Invalid password';
        loginError.classList.remove('hidden');
        passwordInput.value = '';
        passwordInput.focus();
      }
    } catch (e: any) {
      loginError.textContent = 'Connection error: ' + e.message;
      loginError.classList.remove('hidden');
    } finally {
      loginBtn.disabled = false;
    }
  }

  // Show app (hide login)
  function showApp() {
    loginScreen.classList.add('hidden');

    const appContainer = document.getElementById('app-container');
    if (appContainer) {
      appContainer.classList.remove('hidden');
    }

    // Initialize UI controls from saved preferences
    modelSelect.value = selectedModel;
    thinkingToggle.checked = thinkingEnabled;

    // Restore last active tab (default to chat)
    const savedTab = localStorage.getItem('pkm-currentTab') as 'chat' | 'editor' || 'chat';
    switchTab(savedTab);

    loadHistory();
  }

  // Show login (hide app)
  function showLogin() {
    loginScreen.classList.remove('hidden');

    const appContainer = document.getElementById('app-container');
    if (appContainer) {
      appContainer.classList.add('hidden');
    }

    passwordInput.value = '';
    passwordInput.focus();
  }

  // Logout
  function logout() {
    authToken = null;
    localStorage.removeItem('pkm-authToken');
    showLogin();
  }

  // Switch between tabs
  function switchTab(tab: 'chat' | 'editor') {
    const chatApp = document.getElementById('app');
    const editorApp = document.getElementById('editor-app');
    const chatTab = document.getElementById('chat-tab');
    const editorTab = document.getElementById('editor-tab');
    const editorHeaderStatus = document.getElementById('editor-header-status');

    if (tab === 'chat') {
      chatApp?.classList.remove('hidden');
      editorApp?.classList.add('hidden');
      editorHeaderStatus?.classList.add('hidden');
      editorHeaderStatus?.classList.remove('flex');

      chatTab?.classList.remove('bg-white/0');
      chatTab?.classList.add('bg-white/20');
      editorTab?.classList.remove('bg-white/20');
      editorTab?.classList.add('bg-white/0');

      input.focus();
    } else {
      chatApp?.classList.add('hidden');
      editorApp?.classList.remove('hidden');
      editorHeaderStatus?.classList.remove('hidden');
      editorHeaderStatus?.classList.add('flex');

      editorTab?.classList.remove('bg-white/0');
      editorTab?.classList.add('bg-white/20');
      chatTab?.classList.remove('bg-white/20');
      chatTab?.classList.add('bg-white/0');
    }

    // Save current tab preference
    localStorage.setItem('pkm-currentTab', tab);
  }

  // Update model selection
  function updateModel() {
    selectedModel = modelSelect.value;
    localStorage.setItem('pkm-model', selectedModel);
    console.log('Model changed to:', selectedModel);
  }

  // Update thinking toggle
  function updateThinking() {
    thinkingEnabled = thinkingToggle.checked;
    localStorage.setItem('pkm-thinking', thinkingEnabled.toString());
    console.log('Deep thinking:', thinkingEnabled);
  }

  // Verify token on page load
  async function verifyToken() {
    if (!authToken) {
      showLogin();
      return;
    }

    try {
      const res = await fetch('/verify-token', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({token: authToken})
      });

      const data = await res.json();

      if (data.valid) {
        showApp();
      } else {
        authToken = null;
        localStorage.removeItem('pkm-authToken');
        showLogin();
      }
    } catch (e) {
      console.error('Token verification error:', e);
      showLogin();
    }
  }

  // Get auth headers
  function getAuthHeaders(): HeadersInit {
    const headers: HeadersInit = {'Content-Type': 'application/json'};
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }
    return headers;
  }

  // Handle 401 errors
  function handle401() {
    authToken = null;
    localStorage.removeItem('pkm-authToken');
    showLogin();
    alert('Your session has expired. Please log in again.');
  }

  // Send message
  async function send() {
    const message = input.value.trim();
    if (!message) return;

    input.value = '';
    input.style.height = 'auto'; // Reset textarea height
    input.disabled = true;
    sendBtn.disabled = true;

    emptyState.style.display = 'none';

    appendMessage('user', message);

    loading.classList.remove('hidden');
    loading.classList.add('flex');
    chat.scrollTop = chat.scrollHeight;

    try {
      const requestBody: any = {
        message: message,
        session_id: sessionId,
        model: selectedModel
      };

      if (thinkingEnabled) {
        requestBody.thinking = { type: 'enabled', budget_tokens: 10000 };
      }

      const res = await fetch('/query', {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify(requestBody)
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const data = await res.json();

      loading.classList.add('hidden');
      loading.classList.remove('flex');

      appendMessage('assistant', data.response);
    } catch (e: any) {
      loading.classList.add('hidden');
      loading.classList.remove('flex');
      appendMessage('assistant', '❌ Error: ' + e.message);
    } finally {
      input.disabled = false;
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Send example query
  function sendExample(text: string) {
    input.value = text;
    send();
  }

  // Append message to chat
  function appendMessage(role: string, text: string) {
    const div = document.createElement('div');
    div.className = `message ${role}`;

    if (role === 'assistant') {
      let rendered = md.render(text);
      rendered = processDoneItems(rendered);
      rendered = addTokensToImages(rendered);
      div.innerHTML = rendered;
    } else {
      div.textContent = text;
    }

    chat.insertBefore(div, loading);
    chat.scrollTop = chat.scrollHeight;
  }

  // Show session history modal
  async function showSessionHistory() {
    const modal = document.getElementById('session-history-modal')!;
    const sessionList = document.getElementById('session-list')!;

    modal.classList.remove('hidden');
    sessionList.innerHTML = '<div class="text-center text-gray-500 py-8">Loading sessions...</div>';

    try {
      const res = await fetch('/sessions', {
        headers: getAuthHeaders()
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const sessions = await res.json();

      if (sessions.length === 0) {
        sessionList.innerHTML = '<div class="text-center text-gray-500 py-8">No sessions found</div>';
        return;
      }

      // Sort by updated_at descending
      sessions.sort((a: any, b: any) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());

      sessionList.innerHTML = sessions.map((session: any) => {
        const isActive = session.session_id === sessionId;
        const date = new Date(session.updated_at).toLocaleString();
        const preview = session.preview || 'Empty session';

        return `
          <div class="border rounded-lg p-4 mb-3 hover:bg-gray-50 cursor-pointer ${isActive ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}"
               onclick="switchToSession('${session.session_id}')">
            <div class="flex justify-between items-start mb-2">
              <div class="text-sm text-gray-500">${date}</div>
              ${isActive ? '<span class="text-xs px-2 py-1 bg-blue-500 text-white rounded">Current</span>' : ''}
            </div>
            <div class="text-gray-800 truncate mb-1">${preview}</div>
            <div class="text-xs text-gray-500">${session.message_count} messages</div>
          </div>
        `;
      }).join('');
    } catch (e: any) {
      sessionList.innerHTML = `<div class="text-center text-red-500 py-8">Error loading sessions: ${e.message}</div>`;
    }
  }

  // Hide session history modal
  function hideSessionHistory() {
    const modal = document.getElementById('session-history-modal')!;
    modal.classList.add('hidden');
  }

  // Switch to a different session
  async function switchToSession(newSessionId: string) {
    if (newSessionId === sessionId) {
      hideSessionHistory();
      return;
    }

    sessionId = newSessionId;
    localStorage.setItem('pkm-sessionId', sessionId);

    // Clear current chat
    const messages = chat.querySelectorAll('.message');
    messages.forEach(msg => msg.remove());

    // Load new session history
    await loadHistory();

    hideSessionHistory();
    console.log('Switched to session:', sessionId);
  }

  // Start new session
  function newSession() {
    sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem('pkm-sessionId', sessionId);

    const messages = chat.querySelectorAll('.message');
    messages.forEach(msg => msg.remove());

    emptyState.style.display = 'block';

    console.log('New session started:', sessionId);
  }

  // Load conversation history
  async function loadHistory() {
    try {
      const res = await fetch(`/sessions/${sessionId}/history`, {
        headers: getAuthHeaders()
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const history = await res.json();

      if (history.length > 0) {
        emptyState.style.display = 'none';
        history.forEach((msg: any) => appendMessage(msg.role, msg.text));
      }
    } catch (e) {
      console.error('Error loading history:', e);
    }
  }

  // Auto-resize textarea as user types
  function autoResizeTextarea() {
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }

  input.addEventListener('input', autoResizeTextarea);

  // Keyboard shortcuts
  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      input.focus();
    }
  });

  // Set up login form handler
  document.getElementById('login-form')?.addEventListener('submit', handleLogin);

  // Verify token and load app on page load
  verifyToken();

  // Make functions globally available
  (window as any).send = send;
  (window as any).sendExample = sendExample;
  (window as any).showSessionHistory = showSessionHistory;
  (window as any).hideSessionHistory = hideSessionHistory;
  (window as any).switchToSession = switchToSession;
  (window as any).newSession = newSession;
  (window as any).logout = logout;
  (window as any).updateModel = updateModel;
  (window as any).updateThinking = updateThinking;
  (window as any).switchTab = switchTab;
</script>

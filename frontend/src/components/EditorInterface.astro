---
// File editor component
---

<div id="editor-app" class="hidden flex flex-col h-full">
  <!-- File Selector with Filters -->
  <div class="bg-gray-50 px-4 py-3 border-b">
    <div class="flex flex-wrap items-center gap-3">
      <label class="text-sm font-medium text-gray-700">Source:</label>
      <select
        id="source-filter"
        class="px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      >
        <option value="all">All</option>
        <option value="org">Org</option>
        <option value="logseq">Logseq</option>
      </select>

      <label class="text-sm font-medium text-gray-700">Type:</label>
      <select
        id="type-filter"
        class="px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      >
        <option value="all">All</option>
        <option value="journal">Journals</option>
        <option value="page">Pages</option>
        <option value="other">Other</option>
      </select>

      <input
        id="search-filter"
        type="text"
        placeholder="Filter filenames..."
        class="w-48 px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      />

      <label for="file-selector" class="text-sm font-medium text-gray-700">File:</label>
      <select
        id="file-selector"
        class="min-w-64 flex-1 px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      >
        <option value="">Select a file...</option>
      </select>

      <span id="file-count" class="text-sm text-gray-500 whitespace-nowrap"></span>
    </div>
  </div>

  <!-- Editor Container -->
  <div id="editor-container" class="flex-1 overflow-hidden">
    <!-- CodeMirror will be mounted here -->
  </div>
</div>

<style>
  /* CodeMirror styling */
  #editor-container {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    overflow: auto;
  }

  #editor-container .cm-editor {
    height: 100%;
  }

  #editor-container .cm-scroller {
    font-size: 14px;
    line-height: 1.6;
    overflow: auto;
  }
</style>

<script>
  import { EditorView, basicSetup } from 'codemirror';
  import { markdown } from '@codemirror/lang-markdown';
  import { oneDark } from '@codemirror/theme-one-dark';
  import { StreamLanguage } from '@codemirror/language';
  import { emacs } from '@replit/codemirror-emacs';

  // Simple org-mode syntax highlighting
  const orgMode = StreamLanguage.define({
    startState: () => ({ inSourceBlock: false }),
    token: (stream, state) => {
      // Check for source block delimiters
      if (stream.sol() && stream.match(/^[\s]*#\+begin_src/i)) {
        state.inSourceBlock = true;
        stream.skipToEnd();
        return "keyword";
      }

      if (stream.sol() && stream.match(/^[\s]*#\+end_src/i)) {
        state.inSourceBlock = false;
        stream.skipToEnd();
        return "keyword";
      }

      // Inside source block - treat as code
      if (state.inSourceBlock) {
        stream.skipToEnd();
        return "comment";  // CodeMirror uses "comment" for code blocks in some themes
      }

      // Headings (*, **, ***, etc.)
      if (stream.sol() && stream.match(/^\*+\s/)) {
        stream.skipToEnd();
        return "heading";
      }

      // Bold **text**
      if (stream.match(/\*\*[^\*]+\*\*/)) {
        return "strong";
      }

      // Italic /text/
      if (stream.match(/\/[^\/]+\//)) {
        return "emphasis";
      }

      // Code =text= or ~text~
      if (stream.match(/[=~][^=~]+[=~]/)) {
        return "monospace";
      }

      // Links [[url][description]]
      if (stream.match(/\[\[[^\]]+\]\[[^\]]+\]\]/)) {
        return "link";
      }

      // Simple links [[url]]
      if (stream.match(/\[\[[^\]]+\]\]/)) {
        return "link";
      }

      // List items
      if (stream.sol() && stream.match(/^[\s]*[-+]\s/)) {
        return "list";
      }

      // Other #+... directives
      if (stream.sol() && stream.match(/^#\+.*/)) {
        return "meta";
      }

      stream.next();
      return null;
    }
  });

  // State
  let editorView: EditorView | null = null;
  let currentFile: string | null = null;
  let isDirty = false;
  let allFiles: any[] = [];
  let currentFileMtime: number | null = null;  // Track file modification time
  let eventSource: EventSource | null = null;  // SSE connection

  // DOM elements
  const editorContainer = document.getElementById('editor-container')!;
  const fileSelector = document.getElementById('file-selector') as HTMLSelectElement;
  const saveButton = document.getElementById('save-button') as HTMLButtonElement;
  const refreshButton = document.getElementById('refresh-button') as HTMLButtonElement;
  const editorStatus = document.getElementById('editor-status')!;
  const sourceFilter = document.getElementById('source-filter') as HTMLSelectElement;
  const typeFilter = document.getElementById('type-filter') as HTMLSelectElement;
  const searchFilter = document.getElementById('search-filter') as HTMLInputElement;
  const fileCount = document.getElementById('file-count')!;

  // Get auth headers from parent context
  function getAuthHeaders(): HeadersInit {
    const authToken = localStorage.getItem('pkm-authToken');
    const headers: HeadersInit = { 'Content-Type': 'application/json' };
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }
    return headers;
  }

  // Get language mode based on file extension
  function getLanguageMode(filepath: string) {
    if (filepath.endsWith('.org')) {
      return orgMode;
    } else {
      return markdown();
    }
  }

  // Initialize CodeMirror
  function initEditor(filepath: string = '') {
    editorView = new EditorView({
      extensions: [
        basicSetup,
        getLanguageMode(filepath),
        oneDark,
        emacs(),
        EditorView.lineWrapping,  // Enable word wrap
        EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            isDirty = true;
            updateStatus('Modified (unsaved)');
            saveButton.disabled = false;
          }
        })
      ],
      parent: editorContainer,
      doc: ''
    });
  }

  // Load all files from backend
  async function loadFileList() {
    try {
      const res = await fetch('/api/files', {
        headers: getAuthHeaders()
      });

      if (!res.ok) {
        throw new Error(`Failed to load files: ${res.status}`);
      }

      allFiles = await res.json();
      updateStatus(`Loaded ${allFiles.length} files`);
      filterAndPopulateFiles();
    } catch (e: any) {
      updateStatus(`Error loading files: ${e.message}`, true);
      console.error('Failed to load file list:', e);
    }
  }

  // Filter and populate file selector based on current filters
  function filterAndPopulateFiles() {
    const sourceValue = sourceFilter.value;
    const typeValue = typeFilter.value;
    const searchValue = searchFilter.value.toLowerCase();

    // Filter files
    let filtered = allFiles.filter((f: any) => {
      if (sourceValue !== 'all' && f.dir !== sourceValue) return false;
      if (typeValue !== 'all' && f.type !== typeValue) return false;
      if (searchValue && !f.name.toLowerCase().includes(searchValue) && !f.path.toLowerCase().includes(searchValue)) return false;
      return true;
    });

    // Sort: journals by date (newest first), pages and other alphabetically
    const journals = filtered.filter((f: any) => f.type === 'journal');
    const pages = filtered.filter((f: any) => f.type === 'page');
    const other = filtered.filter((f: any) => f.type === 'other');

    journals.sort((a: any, b: any) => b.modified - a.modified);
    pages.sort((a: any, b: any) => a.name.localeCompare(b.name));
    other.sort((a: any, b: any) => a.name.localeCompare(b.name));

    const sorted = [...journals, ...pages, ...other];

    // Clear and populate dropdown
    fileSelector.innerHTML = '<option value="">Select a file...</option>';

    // Group by source and type
    const orgJournals = sorted.filter((f: any) => f.dir === 'org' && f.type === 'journal');
    const orgPages = sorted.filter((f: any) => f.dir === 'org' && f.type === 'page');
    const orgOther = sorted.filter((f: any) => f.dir === 'org' && f.type === 'other');
    const logseqJournals = sorted.filter((f: any) => f.dir === 'logseq' && f.type === 'journal');
    const logseqPages = sorted.filter((f: any) => f.dir === 'logseq' && f.type === 'page');
    const logseqOther = sorted.filter((f: any) => f.dir === 'logseq' && f.type === 'other');

    function addGroup(label: string, files: any[]) {
      if (files.length === 0) return;
      const group = document.createElement('optgroup');
      group.label = `${label} (${files.length})`;
      files.forEach((file: any) => {
        const option = document.createElement('option');
        option.value = file.full_path;
        option.textContent = file.path;
        group.appendChild(option);
      });
      fileSelector.appendChild(group);
    }

    addGroup('Org Journals', orgJournals);
    addGroup('Org Pages', orgPages);
    addGroup('Org Other', orgOther);
    addGroup('Logseq Journals', logseqJournals);
    addGroup('Logseq Pages', logseqPages);
    addGroup('Logseq Other', logseqOther);

    fileCount.textContent = `${sorted.length} file${sorted.length !== 1 ? 's' : ''}`;
  }

  // Load file content
  async function loadFile(filepath: string) {
    // Check for unsaved changes
    if (isDirty && currentFile) {
      if (!confirm('You have unsaved changes. Discard them?')) {
        // Revert selector to current file
        fileSelector.value = currentFile;
        return;
      }
    }

    try {
      updateStatus('Loading...');

      const res = await fetch(`/api/file/${encodeURIComponent(filepath)}`, {
        headers: getAuthHeaders()
      });

      if (!res.ok) {
        throw new Error(`Failed to load file: ${res.status}`);
      }

      const data = await res.json();

      // Reinitialize editor with correct language mode for this file type
      if (editorView) {
        editorView.destroy();
      }
      initEditor(filepath);

      // Set content
      if (editorView) {
        editorView.dispatch({
          changes: {
            from: 0,
            to: 0,
            insert: data.content
          }
        });
      }

      currentFile = filepath;
      currentFileMtime = data.modified || null;  // Track modification time
      isDirty = false;
      saveButton.disabled = true;

      const size = (data.size / 1024).toFixed(1);
      const fileType = filepath.endsWith('.org') ? 'Org' : 'Markdown';
      updateStatus(`Loaded ${data.path} (${size} KB, ${fileType})`);
    } catch (e: any) {
      updateStatus(`Error loading file: ${e.message}`, true);
      console.error('Failed to load file:', e);
    }
  }

  // Save file
  async function saveFile() {
    if (!editorView || !currentFile) return;

    try {
      saveButton.disabled = true;
      updateStatus('Saving...');

      const content = editorView.state.doc.toString();

      const res = await fetch(`/api/file/${encodeURIComponent(currentFile)}`, {
        method: 'PUT',
        headers: getAuthHeaders(),
        body: JSON.stringify({ content })
      });

      if (!res.ok) {
        throw new Error(`Failed to save file: ${res.status}`);
      }

      const data = await res.json();

      isDirty = false;
      const size = (data.size / 1024).toFixed(1);
      updateStatus(`Saved ${data.path} (${size} KB)`);

      // Re-enable after a moment if there are changes
      setTimeout(() => {
        if (!isDirty) {
          saveButton.disabled = true;
        }
      }, 500);
    } catch (e: any) {
      updateStatus(`Error saving file: ${e.message}`, true);
      console.error('Failed to save file:', e);
      saveButton.disabled = false;
    }
  }

  // Refresh file from server
  async function refreshFile() {
    if (!currentFile) return;

    // Warn if there are unsaved changes
    if (isDirty) {
      if (!confirm('You have unsaved changes. Reloading will discard them. Continue?')) {
        return;
      }
    }

    // Reload the file
    await loadFile(currentFile);
  }

  // Update status message
  function updateStatus(message: string, isError: boolean = false) {
    editorStatus.textContent = message;
    if (isError) {
      editorStatus.style.color = '#ef4444';
    } else {
      editorStatus.style.color = 'inherit';
    }
  }

  // Connect to SSE for real-time file updates
  function connectSSE() {
    if (eventSource) {
      return; // Already connected
    }

    try {
      eventSource = new EventSource('/api/events');

      eventSource.onopen = () => {
        // Connection established
      };

      eventSource.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleSSEEvent(message);
        } catch (e) {
          console.error('Failed to parse SSE event:', e, event.data);
        }
      };

      eventSource.onerror = (error) => {
        console.error('SSE error:', error, 'ReadyState:', eventSource?.readyState);
        eventSource?.close();
        eventSource = null;
        // Reconnect after 5 seconds
        setTimeout(connectSSE, 5000);
      };
    } catch (e) {
      console.error('Failed to connect SSE:', e);
    }
  }

  // Handle SSE events
  function handleSSEEvent(message: any) {
    const { type, data } = message;

    if (type === 'connected') {
      return;
    }

    if (type === 'file_changed') {
      handleFileChanged(data);
      return;
    }

    if (type === 'open_file') {
      // Future: handle "open file" command from chat
      handleOpenFile(data);
      return;
    }
  }

  // Handle file change event
  function handleFileChanged(data: any) {
    const { path, mtime } = data;

    if (!currentFile) {
      return;
    }

    // Check if the absolute path ends with the relative path from currentFile
    const currentRelPath = currentFile.includes(':') ? currentFile.split(':', 2)[1] : currentFile;
    if (!path.endsWith(currentRelPath)) {
      return;
    }

    if (isDirty) {
      // File is modified, show notification but don't auto-reload
      updateStatus('File changed on disk (unsaved changes)', true);
      return;
    }

    if (currentFileMtime && mtime <= currentFileMtime) {
      // Mtime hasn't changed (or is older), skip
      return;
    }

    // Auto-reload the file
    loadFile(currentFile);
  }

  // Handle open file event (for future use)
  function handleOpenFile(data: any) {
    const { path } = data;
    // Future: switch to editor tab and load the file
    console.log('Open file requested:', path);
    // loadFile(path);
  }

  // Event handlers
  fileSelector.addEventListener('change', () => {
    const filepath = fileSelector.value;
    if (filepath) {
      loadFile(filepath);
    }
  });

  saveButton.addEventListener('click', saveFile);
  refreshButton.addEventListener('click', refreshFile);

  // Filter event listeners
  sourceFilter.addEventListener('change', filterAndPopulateFiles);
  typeFilter.addEventListener('change', filterAndPopulateFiles);
  searchFilter.addEventListener('input', filterAndPopulateFiles);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const editorApp = document.getElementById('editor-app');
    if (!editorApp || editorApp.classList.contains('hidden')) return;

    // Cmd/Ctrl + S to save
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault();
      if (currentFile && isDirty) {
        saveFile();
      }
    }

    // Cmd/Ctrl + R to refresh
    if ((e.metaKey || e.ctrlKey) && e.key === 'r') {
      e.preventDefault();
      if (currentFile) {
        refreshFile();
      }
    }
  });

  // Initialize when editor becomes visible
  function initEditorWhenVisible() {
    const observer = new MutationObserver(() => {
      const editorApp = document.getElementById('editor-app');
      if (editorApp && !editorApp.classList.contains('hidden')) {
        if (!editorView) {
          // Don't initialize editor until a file is loaded
          // This way we can set the correct language mode
          loadFileList();
          // Connect to SSE for real-time file updates
          connectSSE();
        }
        observer.disconnect();
      }
    });

    observer.observe(document.body, {
      subtree: true,
      attributes: true,
      attributeFilter: ['class']
    });
  }

  // Start observing
  initEditorWhenVisible();

  // Make functions globally available for tab switching
  (window as any).refreshFileList = loadFileList;
</script>

---
// File editor component
---

<div id="editor-app" class="hidden flex flex-col h-full">
  <!-- File Selector with Filters -->
  <div class="bg-gray-50 px-4 py-3 border-b">
    <div class="flex flex-wrap items-center gap-3">
      <label class="text-sm font-medium text-gray-700">Source:</label>
      <select
        id="source-filter"
        class="px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      >
        <option value="all">All</option>
        <option value="org">Org</option>
        <option value="logseq">Logseq</option>
      </select>

      <label class="text-sm font-medium text-gray-700">Type:</label>
      <select
        id="type-filter"
        class="px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      >
        <option value="all">All</option>
        <option value="journal">Journals</option>
        <option value="page">Pages</option>
        <option value="other">Other</option>
      </select>

      <input
        id="search-filter"
        type="text"
        placeholder="Filter filenames..."
        class="w-48 px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      />

      <label for="file-selector" class="text-sm font-medium text-gray-700">File:</label>
      <select
        id="file-selector"
        class="min-w-64 flex-1 px-3 py-1 bg-white border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
      >
        <option value="">Select a file...</option>
      </select>

      <span id="file-count" class="text-sm text-gray-500 whitespace-nowrap"></span>
    </div>
  </div>

  <!-- Editor Container -->
  <div id="editor-container" class="flex-1 overflow-hidden">
    <!-- CodeMirror will be mounted here -->
  </div>
</div>

<!-- Conflict Resolution Modal -->
<div id="conflict-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center" onclick="if(event.target === this) hideConflictModal()">
  <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6">
    <h3 class="text-xl font-bold text-gray-800 mb-3">⚠️ File Modified Remotely</h3>

    <p class="text-sm text-gray-700 mb-4">
      This file was changed on disk while you were editing.
    </p>

    <div class="bg-gray-50 rounded p-3 mb-4 text-sm space-y-1">
      <div class="flex justify-between">
        <span class="text-gray-600">Your changes:</span>
        <span class="font-mono text-gray-800" id="conflict-local-time"></span>
      </div>
      <div class="flex justify-between">
        <span class="text-gray-600">Remote changes:</span>
        <span class="font-mono text-gray-800" id="conflict-remote-time"></span>
      </div>
    </div>

    <div class="flex flex-col gap-2">
      <button
        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
        onclick="resolveConflict('save-mine')"
      >
        Save My Version (Overwrite Remote)
      </button>
      <button
        class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 font-medium"
        onclick="resolveConflict('reload-remote')"
      >
        Reload Remote Version (Discard Mine)
      </button>
      <button
        class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
        onclick="resolveConflict('backup-and-reload')"
      >
        Backup Mine & Reload Remote
      </button>
      <button
        class="px-4 py-2 bg-white border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 font-medium"
        onclick="hideConflictModal()"
      >
        Cancel (Keep Editing)
      </button>
    </div>
  </div>
</div>

<style>
  /* CodeMirror styling */
  #editor-container {
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    overflow: auto;
  }

  #editor-container .cm-editor {
    height: 100%;
  }

  #editor-container .cm-scroller {
    line-height: 1.6;
    overflow: auto;
  }
</style>

<script>
  import { EditorView, basicSetup } from 'codemirror';
  import { markdown } from '@codemirror/lang-markdown';
  import { oneDark } from '@codemirror/theme-one-dark';
  import { StreamLanguage } from '@codemirror/language';
  import { emacs } from '@replit/codemirror-emacs';
  import { foldService, foldEffect } from '@codemirror/language';
  import { Tag, tags } from '@lezer/highlight';
  import { HighlightStyle, syntaxHighlighting } from '@codemirror/language';

  // Constants for localStorage keys
  const STORAGE_KEYS = {
    AUTO_SAVE_ENABLED: 'pkm-autoSave',
    AUTO_SAVE_DELAY: 'pkm-autoSaveDelay',
  } as const;

  // Type definitions
  type ConflictAction = 'save-mine' | 'reload-remote' | 'backup-and-reload';

  // Define custom tags for Org mode
  const orgTags = {
    propertyDrawer: Tag.define(tags.keyword),
    propertyKey: Tag.define(tags.propertyName),
    propertyValue: Tag.define(tags.string),
    srcBlockDelimiter: Tag.define(tags.keyword),
    srcBlockContent: Tag.define(tags.monospace),
    heading1: Tag.define(tags.heading1),
    heading2: Tag.define(tags.heading2),
    heading3: Tag.define(tags.heading3),
    headingTags: Tag.define(tags.meta),
    tableLine: Tag.define(tags.contentSeparator),
    checkboxUnchecked: Tag.define(tags.list),
    checkboxChecked: Tag.define(tags.list),
    checkboxCheckedText: Tag.define(tags.strikethrough),
  };

  // Define highlight styles for Org mode
  const orgHighlightStyle = HighlightStyle.define([
    // Property drawers (custom, smaller text)
    { tag: orgTags.propertyDrawer, color: '#61afef', fontWeight: 'bold', fontSize: '0.85em' },
    { tag: orgTags.propertyKey, color: '#e5c07b', fontWeight: '600', fontSize: '0.85em' },
    { tag: orgTags.propertyValue, color: '#98c379', fontSize: '0.85em' },

    // Source blocks (custom)
    { tag: orgTags.srcBlockDelimiter, color: '#c678dd', fontWeight: 'bold' },
    { tag: orgTags.srcBlockContent, color: '#abb2bf', backgroundColor: 'rgba(0, 0, 0, 0.2)' },

    // Headings (larger text for h1 and h2)
    { tag: orgTags.heading1, color: '#e06c75', fontWeight: 'bold', fontSize: '1.4em' },
    { tag: orgTags.heading2, color: '#e06c75', fontWeight: 'bold', fontSize: '1.2em' },
    { tag: orgTags.heading3, color: '#e06c75', fontWeight: 'bold', fontSize: '1.05em' },
    { tag: tags.heading, color: '#e06c75', fontWeight: 'bold' }, // h4+
    { tag: orgTags.headingTags, color: '#5c6370', fontStyle: 'italic' }, // :tags:at:end:

    // Tables
    { tag: orgTags.tableLine, color: '#61afef', backgroundColor: 'rgba(0, 0, 0, 0.3)' },

    // Checkboxes
    { tag: orgTags.checkboxUnchecked, color: '#e5c07b', fontWeight: 'bold' }, // Bright orange/amber - needs attention!
    { tag: orgTags.checkboxChecked, color: '#7fad5f', fontWeight: 'bold' }, // Darker green - done!
    { tag: orgTags.checkboxCheckedText, color: '#5c6370', textDecoration: 'line-through' },

    // Standard formatting
    { tag: tags.strong, fontWeight: 'bold', color: '#d19a66' },
    { tag: tags.emphasis, fontStyle: 'italic', color: '#c678dd' },
    { tag: tags.monospace, fontFamily: 'monospace', color: '#98c379' },
    { tag: tags.link, color: '#56b6c2', textDecoration: 'underline' },
    { tag: tags.list, color: '#61afef' },
    { tag: tags.meta, color: '#5c6370', fontStyle: 'italic' },
  ]);

  // Folding service for property drawers
  const orgFoldService = foldService.of((state, from, to) => {
    const line = state.doc.lineAt(from);
    const text = line.text;

    // Check if this line starts a property drawer
    if (text.match(/^[\s]*:PROPERTIES:/i)) {
      // Find the matching :END:
      let endLine = line.number + 1;
      while (endLine <= state.doc.lines) {
        const currentLine = state.doc.line(endLine);
        if (currentLine.text.match(/^[\s]*:END:/i)) {
          // Return fold range from start of :PROPERTIES: to end of :END:
          return {
            from: line.to,
            to: currentLine.from
          };
        }
        endLine++;
      }
    }

    return null;
  });

  // Simple org-mode syntax highlighting
  const orgMode = StreamLanguage.define({
    startState: () => ({
      inSourceBlock: false,
      inPropertyDrawer: false,
      inCheckedItem: false
    }),
    tokenTable: {
      "org-propertyDrawer": orgTags.propertyDrawer,
      "org-propertyKey": orgTags.propertyKey,
      "org-propertyValue": orgTags.propertyValue,
      "org-srcBlockDelimiter": orgTags.srcBlockDelimiter,
      "org-srcBlockContent": orgTags.srcBlockContent,
      "org-heading1": orgTags.heading1,
      "org-heading2": orgTags.heading2,
      "org-heading3": orgTags.heading3,
      "org-headingTags": orgTags.headingTags,
      "org-tableLine": orgTags.tableLine,
      "org-checkboxUnchecked": orgTags.checkboxUnchecked,
      "org-checkboxChecked": orgTags.checkboxChecked,
      "org-checkboxCheckedText": orgTags.checkboxCheckedText,
    },
    token: (stream, state) => {
      // Reset checked item state at start of line
      if (stream.sol()) {
        state.inCheckedItem = false;
      }

      // Table lines (start and end with |)
      if (stream.sol() && stream.match(/^[\s]*\|.*\|[\s]*$/)) {
        return "org-tableLine";
      }

      // Checkbox items - checked: - [X]
      if (stream.sol() && stream.match(/^[\s]*-[\s]+\[[\s]*[Xx][\s]*\]/)) {
        state.inCheckedItem = true;
        return "org-checkboxChecked";
      }

      // Checkbox items - unchecked: - [ ]
      if (stream.sol() && stream.match(/^[\s]*-[\s]+\[[\s]*\]/)) {
        return "org-checkboxUnchecked";
      }

      // Text after checked checkbox (apply strikethrough)
      if (state.inCheckedItem && !stream.eol()) {
        stream.skipToEnd();
        return "org-checkboxCheckedText";
      }

      // Check for property drawer start
      if (stream.sol() && stream.match(/^[\s]*:PROPERTIES:/i)) {
        state.inPropertyDrawer = true;
        return "org-propertyDrawer";
      }

      // Check for property drawer end
      if (stream.sol() && stream.match(/^[\s]*:END:/i)) {
        state.inPropertyDrawer = false;
        return "org-propertyDrawer";
      }

      // Inside property drawer - parse property lines
      if (state.inPropertyDrawer) {
        if (stream.sol() && stream.match(/^[\s]*:([A-Z_-]+):/)) {
          // Property key found, now get the value
          const value = stream.match(/[\s]*.*/);
          if (value && value[0].trim()) {
            // We need to return the key styling, value will be styled on next token
            stream.backUp(value[0].length);
            return "org-propertyKey";
          }
          return "org-propertyKey";
        }
        // If we're past the key, this is the value
        if (!stream.sol() && stream.peek() !== ':') {
          stream.skipToEnd();
          return "org-propertyValue";
        }
      }

      // Check for source block delimiters
      if (stream.sol() && stream.match(/^[\s]*#\+begin_src/i)) {
        state.inSourceBlock = true;
        stream.skipToEnd();
        return "org-srcBlockDelimiter";
      }

      if (stream.sol() && stream.match(/^[\s]*#\+end_src/i)) {
        state.inSourceBlock = false;
        stream.skipToEnd();
        return "org-srcBlockDelimiter";
      }

      // Inside source block - treat as code
      if (state.inSourceBlock) {
        stream.skipToEnd();
        return "org-srcBlockContent";
      }

      // Headings (*, **, ***, etc.)
      if (stream.sol()) {
        const match = stream.match(/^(\*+)\s/);
        if (match) {
          const level = match[1].length;
          // Check if there are tags at the end of the line (pattern: :tag1:tag2:)
          const restOfLine = stream.string.slice(stream.pos);
          const tagsMatch = restOfLine.match(/^(.*?)((?:\s+)?:[a-zA-Z0-9_@]+(?::[a-zA-Z0-9_@]+)*:)\s*$/);

          if (tagsMatch) {
            // There are tags - consume just the heading text
            stream.pos += tagsMatch[1].length;
          } else {
            // No tags - consume entire line
            stream.skipToEnd();
          }

          if (level === 1) return "org-heading1";
          if (level === 2) return "org-heading2";
          if (level === 3) return "org-heading3";
          return "heading"; // h4 and beyond use standard heading tag
        }
      }

      // Org-mode tags at end of heading line (:tag1:tag2:)
      if (stream.match(/(?:\s+)?:[a-zA-Z0-9_@]+(?::[a-zA-Z0-9_@]+)*:\s*$/)) {
        return "org-headingTags";
      }

      // Bold **text**
      if (stream.match(/\*\*[^\*]+\*\*/)) {
        return "strong";
      }

      // Italic /text/
      if (stream.match(/\/[^\/]+\//)) {
        return "emphasis";
      }

      // Code =text= or ~text~
      if (stream.match(/[=~][^=~]+[=~]/)) {
        return "monospace";
      }

      // Links [[url][description]]
      if (stream.match(/\[\[[^\]]+\]\[[^\]]+\]\]/)) {
        return "link";
      }

      // Simple links [[url]]
      if (stream.match(/\[\[[^\]]+\]\]/)) {
        return "link";
      }

      // List items
      if (stream.sol() && stream.match(/^[\s]*[-+]\s/)) {
        return "list";
      }

      // Other #+... directives
      if (stream.sol() && stream.match(/^#\+.*/)) {
        return "meta";
      }

      stream.next();
      return null;
    }
  });

  // State
  let editorView: EditorView | null = null;
  let currentFile: string | null = null;
  let isDirty = false;
  let allFiles: any[] = [];
  let currentFileMtime: number | null = null;  // Track file modification time
  let eventSource: EventSource | null = null;  // SSE connection

  // Auto-save state
  let autoSaveTimeout: number | null = null;
  let lastSaveTime: number | null = null;
  let conflictDetected = false;
  let statusUpdateInterval: number | null = null;

  // Cached auto-save settings (for performance - avoid reading localStorage on every keystroke)
  let cachedAutoSaveEnabled = localStorage.getItem(STORAGE_KEYS.AUTO_SAVE_ENABLED) !== 'false';
  let cachedAutoSaveDelay = parseInt(localStorage.getItem(STORAGE_KEYS.AUTO_SAVE_DELAY) || '2000');

  // DOM elements
  const editorContainer = document.getElementById('editor-container')!;
  const fileSelector = document.getElementById('file-selector') as HTMLSelectElement;
  const saveButton = document.getElementById('save-button') as HTMLButtonElement;
  const refreshButton = document.getElementById('refresh-button') as HTMLButtonElement;
  const editorStatus = document.getElementById('editor-status')!;
  const sourceFilter = document.getElementById('source-filter') as HTMLSelectElement;
  const typeFilter = document.getElementById('type-filter') as HTMLSelectElement;
  const searchFilter = document.getElementById('search-filter') as HTMLInputElement;
  const fileCount = document.getElementById('file-count')!;

  // Debounce helper - calls function on trailing edge after delay
  function debounce<T extends (...args: any[]) => any>(func: T, delay: number): (...args: Parameters<T>) => void {
    let timeoutId: number | undefined;
    return function(this: any, ...args: Parameters<T>) {
      const context = this;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(context, args), delay) as unknown as number;
    };
  }

  // Get auth headers from parent context
  function getAuthHeaders(): HeadersInit {
    const authToken = localStorage.getItem('pkm-authToken');
    const headers: HeadersInit = { 'Content-Type': 'application/json' };
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }
    return headers;
  }

  // Get language mode based on file extension
  function getLanguageMode(filepath: string) {
    if (filepath.endsWith('.org')) {
      return orgMode;
    } else {
      return markdown();
    }
  }

  // Auto-fold all property drawers in the document
  function autoFoldPropertyDrawers() {
    if (!editorView) return;

    const effects: any[] = [];
    const doc = editorView.state.doc;

    // Find all :PROPERTIES: lines and fold them
    for (let i = 1; i <= doc.lines; i++) {
      const line = doc.line(i);
      if (line.text.match(/^[\s]*:PROPERTIES:/i)) {
        // Check if there's a matching :END:
        let endLine = i + 1;
        while (endLine <= doc.lines) {
          const currentLine = doc.line(endLine);
          if (currentLine.text.match(/^[\s]*:END:/i)) {
            // Found matching :END:, create fold effect
            effects.push(foldEffect.of({ from: line.to, to: currentLine.from }));
            break;
          }
          endLine++;
        }
      }
    }

    // Apply all fold effects at once
    if (effects.length > 0) {
      editorView.dispatch({ effects });
    }
  }

  // Initialize CodeMirror
  function initEditor(filepath: string = '') {
    const extensions = [
      basicSetup,
      getLanguageMode(filepath),
      oneDark,
      emacs(),
      EditorView.lineWrapping,  // Enable word wrap
      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          isDirty = true;
          updateStatus('Modified (unsaved)');
          saveButton.disabled = false;

          // Schedule auto-save if enabled
          scheduleAutoSave();
        }
      }),
      // Add bottom padding and font size for easier mobile editing
      EditorView.theme({
        ".cm-scroller": {
          paddingBottom: "10vh",
          fontSize: "16px"
        },
        // Larger font on mobile
        "@media (max-width: 768px)": {
          ".cm-scroller": {
            fontSize: "18px"
          }
        }
      }),
      // Enable auto-capitalization on mobile keyboards
      EditorView.contentAttributes.of({
        autocapitalize: 'on',
        autocorrect: 'on',
        spellcheck: 'true'
      })
    ];

    // Add org-specific extensions for .org files
    if (filepath.endsWith('.org')) {
      extensions.push(
        syntaxHighlighting(orgHighlightStyle),
        orgFoldService  // basicSetup already includes foldGutter()
      );
    }

    editorView = new EditorView({
      extensions,
      parent: editorContainer,
      doc: ''
    });
  }

  // Load all files from backend
  async function loadFileList() {
    try {
      const res = await fetch('/api/files', {
        headers: getAuthHeaders()
      });

      if (!res.ok) {
        throw new Error(`Failed to load files: ${res.status}`);
      }

      allFiles = await res.json();
      updateStatus(`Loaded ${allFiles.length} files`);
      filterAndPopulateFiles();
    } catch (e: any) {
      updateStatus(`Error loading files: ${e.message}`, true);
      console.error('Failed to load file list:', e);
    }
  }

  // Debounced version for automatic updates (waits 2s after last call)
  const debouncedLoadFileList = debounce(loadFileList, 2000);

  // Filter and populate file selector based on current filters
  function filterAndPopulateFiles() {
    const sourceValue = sourceFilter.value;
    const typeValue = typeFilter.value;
    const searchValue = searchFilter.value.toLowerCase();

    // Filter files
    let filtered = allFiles.filter((f: any) => {
      if (sourceValue !== 'all' && f.dir !== sourceValue) return false;
      if (typeValue !== 'all' && f.type !== typeValue) return false;
      if (searchValue && !f.name.toLowerCase().includes(searchValue) && !f.path.toLowerCase().includes(searchValue)) return false;
      return true;
    });

    // Sort: journals by date (newest first), pages and other alphabetically
    const journals = filtered.filter((f: any) => f.type === 'journal');
    const pages = filtered.filter((f: any) => f.type === 'page');
    const other = filtered.filter((f: any) => f.type === 'other');

    journals.sort((a: any, b: any) => b.modified - a.modified);
    pages.sort((a: any, b: any) => a.name.localeCompare(b.name));
    other.sort((a: any, b: any) => a.name.localeCompare(b.name));

    const sorted = [...journals, ...pages, ...other];

    // Clear and populate dropdown
    fileSelector.innerHTML = '<option value="">Select a file...</option>';

    // Group by source and type
    const orgJournals = sorted.filter((f: any) => f.dir === 'org' && f.type === 'journal');
    const orgPages = sorted.filter((f: any) => f.dir === 'org' && f.type === 'page');
    const orgOther = sorted.filter((f: any) => f.dir === 'org' && f.type === 'other');
    const logseqJournals = sorted.filter((f: any) => f.dir === 'logseq' && f.type === 'journal');
    const logseqPages = sorted.filter((f: any) => f.dir === 'logseq' && f.type === 'page');
    const logseqOther = sorted.filter((f: any) => f.dir === 'logseq' && f.type === 'other');

    function addGroup(label: string, files: any[]) {
      if (files.length === 0) return;
      const group = document.createElement('optgroup');
      group.label = `${label} (${files.length})`;
      files.forEach((file: any) => {
        const option = document.createElement('option');
        option.value = file.full_path;
        option.textContent = file.path;
        group.appendChild(option);
      });
      fileSelector.appendChild(group);
    }

    addGroup('Org Journals', orgJournals);
    addGroup('Org Pages', orgPages);
    addGroup('Org Other', orgOther);
    addGroup('Logseq Journals', logseqJournals);
    addGroup('Logseq Pages', logseqPages);
    addGroup('Logseq Other', logseqOther);

    fileCount.textContent = `${sorted.length} file${sorted.length !== 1 ? 's' : ''}`;
  }

  // Load file content
  async function loadFile(filepath: string) {
    // Check for unsaved changes
    if (isDirty && currentFile) {
      if (!confirm('You have unsaved changes. Discard them?')) {
        // Revert selector to current file
        fileSelector.value = currentFile;
        return;
      }
    }

    // Clean up auto-save timers from previous file
    cleanupAutoSaveTimers();
    lastSaveTime = null;
    conflictDetected = false;

    try {
      updateStatus('Loading...');

      const res = await fetch(`/api/file/${encodeURIComponent(filepath)}`, {
        headers: getAuthHeaders()
      });

      if (!res.ok) {
        throw new Error(`Failed to load file: ${res.status}`);
      }

      const data = await res.json();

      // Reinitialize editor with correct language mode for this file type
      if (editorView) {
        editorView.destroy();
      }
      initEditor(filepath);

      // Set content
      if (editorView) {
        editorView.dispatch({
          changes: {
            from: 0,
            to: 0,
            insert: data.content
          }
        });

        // Auto-fold property drawers for .org files
        if (filepath.endsWith('.org')) {
          // Use setTimeout to ensure the document is fully parsed
          setTimeout(() => autoFoldPropertyDrawers(), 50);
        }
      }

      currentFile = filepath;
      currentFileMtime = data.modified || null;  // Track modification time
      isDirty = false;
      saveButton.disabled = true;

      // Update file selector to show current file
      // If the file isn't in the dropdown (due to filtering), add it temporarily
      const existingOption = Array.from(fileSelector.options).find(
        opt => opt.value === filepath
      );
      if (!existingOption) {
        // File not in filtered list, add it
        const option = document.createElement('option');
        option.value = filepath;
        option.textContent = filepath.split('/').pop() || filepath;
        fileSelector.insertBefore(option, fileSelector.options[1]); // Insert after "Select a file..."
      }
      fileSelector.value = filepath;

      const size = (data.size / 1024).toFixed(1);
      const fileType = filepath.endsWith('.org') ? 'Org' : 'Markdown';
      updateStatus(`Loaded ${data.path} (${size} KB, ${fileType})`);
    } catch (e: any) {
      updateStatus(`Error loading file: ${e.message}`, true);
      console.error('Failed to load file:', e);
    }
  }

  // Save file
  async function saveFile() {
    if (!editorView || !currentFile) return;

    try {
      saveButton.disabled = true;
      updateStatus('Saving...');

      const content = editorView.state.doc.toString();

      const res = await fetch(`/api/file/${encodeURIComponent(currentFile)}`, {
        method: 'PUT',
        headers: getAuthHeaders(),
        body: JSON.stringify({ content })
      });

      if (!res.ok) {
        throw new Error(`Failed to save file: ${res.status}`);
      }

      const data = await res.json();

      isDirty = false;
      const size = (data.size / 1024).toFixed(1);
      updateStatus(`Saved ${data.path} (${size} KB)`);

      // Re-enable after a moment if there are changes
      setTimeout(() => {
        if (!isDirty) {
          saveButton.disabled = true;
        }
      }, 500);
    } catch (e: any) {
      updateStatus(`Error saving file: ${e.message}`, true);
      console.error('Failed to save file:', e);
      saveButton.disabled = false;
    }
  }

  // Refresh file from server
  async function refreshFile() {
    // Always refresh the file list first (immediate, not debounced - user action)
    await loadFileList();

    // Then reload current file if one is open
    if (!currentFile) return;

    // Warn if there are unsaved changes
    if (isDirty) {
      if (!confirm('You have unsaved changes. Reloading will discard them. Continue?')) {
        return;
      }
    }

    // Reload the file
    await loadFile(currentFile);
  }

  // Update status message
  function updateStatus(message: string, isError: boolean = false) {
    editorStatus.textContent = message;
    if (isError) {
      editorStatus.style.color = '#ef4444';
    } else {
      editorStatus.style.color = 'inherit';
    }
  }

  // Auto-save functions
  function cleanupAutoSaveTimers() {
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
      autoSaveTimeout = null;
    }
    if (statusUpdateInterval) {
      clearInterval(statusUpdateInterval);
      statusUpdateInterval = null;
    }
  }

  function refreshAutoSaveSettings() {
    cachedAutoSaveEnabled = localStorage.getItem(STORAGE_KEYS.AUTO_SAVE_ENABLED) !== 'false';
    cachedAutoSaveDelay = parseInt(localStorage.getItem(STORAGE_KEYS.AUTO_SAVE_DELAY) || '2000');
  }

  function scheduleAutoSave() {
    if (!cachedAutoSaveEnabled || !isDirty || !currentFile || conflictDetected) {
      return;
    }

    // Clear existing timeout
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }

    // Update status to show countdown
    const seconds = (cachedAutoSaveDelay / 1000).toFixed(0);
    updateStatus(`Modified • Auto-saving in ${seconds}s...`);

    // Schedule save
    autoSaveTimeout = setTimeout(async () => {
      await performAutoSave();
    }, cachedAutoSaveDelay) as unknown as number;
  }

  async function performAutoSave() {
    if (!editorView || !currentFile || !isDirty) return;

    // Check for conflict (detected by SSE in real-time)
    if (conflictDetected) {
      updateStatus('⚠️ Auto-save paused (conflict detected)', true);
      return;
    }

    try {
      updateStatus('Auto-saving...');
      const content = editorView.state.doc.toString();

      const res = await fetch(`/api/file/${encodeURIComponent(currentFile)}`, {
        method: 'PUT',
        headers: getAuthHeaders(),
        body: JSON.stringify({ content })
      });

      if (!res.ok) {
        throw new Error(`Failed to save: ${res.status}`);
      }

      const data = await res.json();

      // Update state
      currentFileMtime = data.modified;
      isDirty = false;
      lastSaveTime = Date.now();
      saveButton.disabled = true;

      const size = (data.size / 1024).toFixed(1);
      updateStatus(`Auto-saved (${size} KB)`);

      // Start updating "X seconds ago"
      startStatusUpdateTimer();
    } catch (e: any) {
      updateStatus(`Auto-save failed: ${e.message}`, true);
      console.error('Auto-save error:', e);
    }
  }

  function startStatusUpdateTimer() {
    // Clear existing interval
    if (statusUpdateInterval) {
      clearInterval(statusUpdateInterval);
    }

    // Update every 5 seconds to show "Saved X seconds ago"
    statusUpdateInterval = setInterval(() => {
      if (!isDirty && lastSaveTime && !conflictDetected) {
        const secondsAgo = Math.floor((Date.now() - lastSaveTime) / 1000);
        if (secondsAgo < 60) {
          updateStatus(`Saved ${secondsAgo}s ago`);
        } else {
          const minutesAgo = Math.floor(secondsAgo / 60);
          updateStatus(`Saved ${minutesAgo}m ago`);
        }
      }
    }, 5000) as unknown as number;
  }

  function showConflictModal(remoteMtime: number) {
    const modal = document.getElementById('conflict-modal')!;
    const localTime = document.getElementById('conflict-local-time')!;
    const remoteTime = document.getElementById('conflict-remote-time')!;

    if (currentFileMtime) {
      const localDate = new Date(currentFileMtime * 1000);
      localTime.textContent = localDate.toLocaleTimeString();
    } else {
      localTime.textContent = 'Unknown';
    }

    const remoteDate = new Date(remoteMtime * 1000);
    remoteTime.textContent = remoteDate.toLocaleTimeString();

    modal.classList.remove('hidden');
  }

  function hideConflictModal() {
    const modal = document.getElementById('conflict-modal')!;
    modal.classList.add('hidden');
  }

  async function resolveConflict(action: ConflictAction) {
    hideConflictModal();
    conflictDetected = false;

    if (action === 'save-mine') {
      // Force save, overwriting remote
      updateStatus('Saving your version...');
      await saveFile();

    } else if (action === 'reload-remote') {
      // Discard local, reload remote
      if (currentFile) {
        await loadFile(currentFile);
      }

    } else if (action === 'backup-and-reload') {
      // Create backup, then reload
      await createBackup();
      if (currentFile) {
        await loadFile(currentFile);
      }
    }
  }

  async function createBackup() {
    if (!editorView || !currentFile) return;

    const content = editorView.state.doc.toString();
    const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0];

    // Handle files with and without extensions correctly
    const lastSlash = currentFile.lastIndexOf('/');
    const fileName = lastSlash >= 0 ? currentFile.substring(lastSlash + 1) : currentFile;
    const hasExtension = fileName.includes('.') && !fileName.startsWith('.');

    let backupPath: string;
    if (hasExtension) {
      backupPath = currentFile.replace(/(\.\w+)$/, `.backup-${timestamp}$1`);
    } else {
      // Files without extensions (README, Makefile, etc.)
      backupPath = `${currentFile}.backup-${timestamp}`;
    }

    try {
      updateStatus('Creating backup...');

      const res = await fetch(`/api/file/${encodeURIComponent(backupPath)}`, {
        method: 'PUT',
        headers: getAuthHeaders(),
        body: JSON.stringify({ content })
      });

      if (!res.ok) {
        throw new Error(`Failed to create backup: ${res.status}`);
      }

      const filename = backupPath.split('/').pop() || 'backup';
      updateStatus(`Backup created: ${filename}`);
    } catch (e: any) {
      console.error('Failed to create backup:', e);
      updateStatus('Failed to create backup', true);
    }
  }

  // Connect to SSE for real-time file updates
  function connectSSE() {
    if (eventSource) {
      return; // Already connected
    }

    try {
      // Get session ID from global context
      const getSessionId = (window as any).getSessionId;
      const sessionId = getSessionId ? getSessionId() : null;

      // Connect with session ID as query parameter
      const url = sessionId ? `/api/events?session_id=${encodeURIComponent(sessionId)}` : '/api/events';
      eventSource = new EventSource(url);

      eventSource.onopen = () => {
        // Connection established
      };

      eventSource.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleSSEEvent(message);
        } catch (e) {
          console.error('Failed to parse SSE event:', e, event.data);
        }
      };

      eventSource.onerror = (error) => {
        console.error('SSE error:', error, 'ReadyState:', eventSource?.readyState);
        eventSource?.close();
        eventSource = null;
        // Reconnect after 5 seconds
        setTimeout(connectSSE, 5000);
      };
    } catch (e) {
      console.error('Failed to connect SSE:', e);
    }
  }

  // Handle SSE events
  function handleSSEEvent(message: any) {
    const { type, data } = message;

    if (type === 'connected') {
      return;
    }

    if (type === 'file_changed') {
      handleFileChanged(data);
      return;
    }

    if (type === 'open_file') {
      // Future: handle "open file" command from chat
      handleOpenFile(data);
      return;
    }
  }

  // Handle file change event
  function handleFileChanged(data: any) {
    const { path, mtime } = data;

    // Refresh file list (debounced - waits for file changes to settle)
    debouncedLoadFileList();

    if (!currentFile) {
      return;
    }

    // Check if the absolute path ends with the relative path from currentFile
    const currentRelPath = currentFile.includes(':') ? currentFile.split(':', 2)[1] : currentFile;
    if (!path.endsWith(currentRelPath)) {
      return;
    }

    if (isDirty) {
      // File is modified, show notification but don't auto-reload
      conflictDetected = true;
      updateStatus('⚠️ File changed on disk - conflicts need resolution', true);

      // If auto-save is enabled, show conflict modal
      if (cachedAutoSaveEnabled) {
        showConflictModal(mtime);
      }
      return;
    }

    if (currentFileMtime && mtime <= currentFileMtime) {
      // Mtime hasn't changed (or is older), skip
      return;
    }

    // Auto-reload the file
    loadFile(currentFile);
  }

  // Handle open file event from SSE
  function handleOpenFile(data: any) {
    const { path } = data;

    if (!path) {
      console.error('Open file event missing path:', data);
      return;
    }

    console.log('Open file requested:', path);

    // Switch to editor tab if not already there
    const switchTabFn = (window as any).switchTab;
    if (switchTabFn) {
      switchTabFn('editor');
    }

    // Wait a moment for tab switch to complete, then load the file
    setTimeout(() => {
      // Update file selector to show this file
      fileSelector.value = path;

      // Load the file
      loadFile(path);
    }, 100);
  }

  // Event handlers
  fileSelector.addEventListener('change', () => {
    const filepath = fileSelector.value;
    if (filepath) {
      loadFile(filepath);
    }
  });

  saveButton.addEventListener('click', saveFile);
  refreshButton.addEventListener('click', refreshFile);

  // Filter event listeners
  sourceFilter.addEventListener('change', filterAndPopulateFiles);
  typeFilter.addEventListener('change', filterAndPopulateFiles);
  searchFilter.addEventListener('input', filterAndPopulateFiles);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const editorApp = document.getElementById('editor-app');
    if (!editorApp || editorApp.classList.contains('hidden')) return;

    // Cmd/Ctrl + S to save
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault();
      if (currentFile && isDirty) {
        saveFile();
      }
    }

    // Cmd/Ctrl + R to refresh
    if ((e.metaKey || e.ctrlKey) && e.key === 'r') {
      e.preventDefault();
      if (currentFile) {
        refreshFile();
      }
    }
  });

  // Initialize when editor becomes visible
  function initEditorWhenVisible() {
    const observer = new MutationObserver(() => {
      const editorApp = document.getElementById('editor-app');
      if (editorApp && !editorApp.classList.contains('hidden')) {
        if (!editorView) {
          // Don't initialize editor until a file is loaded
          // This way we can set the correct language mode
          loadFileList();
        }
        observer.disconnect();
      }
    });

    observer.observe(document.body, {
      subtree: true,
      attributes: true,
      attributeFilter: ['class']
    });
  }

  // Start observing for editor initialization
  initEditorWhenVisible();

  // Wait for session ID to be available, then connect to SSE
  // This allows receiving open_file events from chat
  let sessionWaitCount = 0;
  function waitForSessionAndConnect() {
    const getSessionId = (window as any).getSessionId;
    if (getSessionId && getSessionId()) {
      console.log('Session ID available, connecting to SSE with session:', getSessionId());
      connectSSE();
    } else if (sessionWaitCount < 50) { // Max 5 seconds
      // Check again in 100ms
      sessionWaitCount++;
      setTimeout(waitForSessionAndConnect, 100);
    } else {
      console.error('Timeout waiting for session ID, connecting without it');
      connectSSE();
    }
  }
  waitForSessionAndConnect();

  // Listen for localStorage changes from other tabs (settings page)
  window.addEventListener('storage', (e) => {
    if (e.key === STORAGE_KEYS.AUTO_SAVE_ENABLED) {
      cachedAutoSaveEnabled = e.newValue !== 'false';
    }
    if (e.key === STORAGE_KEYS.AUTO_SAVE_DELAY) {
      cachedAutoSaveDelay = parseInt(e.newValue || '2000');
    }
  });

  // Make functions globally available for tab switching and conflict resolution
  (window as any).refreshFileList = loadFileList;
  (window as any).resolveConflict = resolveConflict;
  (window as any).hideConflictModal = hideConflictModal;
  (window as any).cleanupAutoSaveTimers = cleanupAutoSaveTimers;
  (window as any).refreshAutoSaveSettings = refreshAutoSaveSettings;
</script>

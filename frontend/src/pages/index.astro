---
import Layout from '../layouts/Layout.astro';
import LoginForm from '../components/LoginForm.astro';
import ChatInterface from '../components/ChatInterface.astro';
import EditorInterface from '../components/EditorInterface.astro';
---

<Layout title="GCO PKM Assistant">
  <LoginForm />

  <!-- App Container -->
  <div id="app-container" class="hidden h-screen flex flex-col overflow-hidden">
    <!-- Unified Header - Always visible at top -->
    <div class="bg-blue-500 text-white px-4 py-3 shadow-md flex items-center gap-4 flex-shrink-0 min-h-[56px] sticky top-0 z-10">
      <h1 class="text-xl font-semibold">GCO PKM Assistant</h1>

      <!-- Tab buttons -->
      <div class="flex gap-2">
        <button
          id="chat-tab"
          class="px-3 py-1.5 bg-white/20 rounded text-sm"
          onclick="switchTab('chat')"
        >
          Chat
        </button>
        <button
          id="editor-tab"
          class="px-3 py-1.5 bg-white/0 rounded text-sm"
          onclick="switchTab('editor')"
        >
          Editor
        </button>
      </div>

      <!-- Right side content -->
      <div class="ml-auto flex items-center gap-4">
        <!-- Editor status (shown only when in editor tab) -->
        <div id="editor-header-status" class="hidden items-center gap-4">
          <span id="editor-status" class="text-sm"></span>
          <button
            id="save-button"
            class="px-4 py-1.5 bg-white text-blue-600 rounded-lg hover:bg-gray-100 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Save
          </button>
          <button
            id="refresh-button"
            class="px-4 py-1.5 bg-white text-gray-600 rounded-lg hover:bg-gray-100 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
            title="Reload file from server"
          >
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M21 10C21 10 18.995 7.26822 17.3662 5.63824C15.7373 4.00827 13.4864 3 11 3C6.02944 3 2 7.02944 2 12C2 16.9706 6.02944 21 11 21C15.1031 21 18.5649 18.2543 19.6482 14.5M21 10V4M21 10H15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <!-- Settings Link -->
        <a href="/settings" class="p-2 bg-white/10 hover:bg-white/20 rounded-lg transition-colors" title="Settings">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
        </a>
      </div>
    </div>

    <!-- Content Area -->
    <div class="flex-1 overflow-hidden">
      <ChatInterface />
      <EditorInterface />
    </div>
  </div>

  <!-- Session History Modal -->
  <div id="session-history-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target === this) hideSessionHistory()">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] flex flex-col">
      <div class="px-6 py-4 border-b flex justify-between items-center">
        <h2 class="text-xl font-semibold text-gray-800">Session History</h2>
        <button onclick="hideSessionHistory()" class="text-gray-500 hover:text-gray-700">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div id="session-list" class="flex-1 overflow-y-auto p-4">
        <div class="text-center text-gray-500 py-8">Loading sessions...</div>
      </div>
    </div>
  </div>
</Layout>

<script>
  import { VoiceInput } from '../utils/VoiceInput';

  // Initialize markdown-it with task-lists plugin
  const md = (window as any).markdownit({
    html: false,
    linkify: true,
    typographer: true
  }).use((window as any).markdownitTaskLists, {enabled: true});

  // Post-process HTML to convert "DONE" items to checked checkboxes
  function processDoneItems(html: string): string {
    const div = document.createElement('div');
    div.innerHTML = html;

    // Find all list items
    const listItems = div.querySelectorAll('li');

    listItems.forEach(li => {
      // Skip if already a task-list-item (handled by markdown-it-task-lists)
      if (li.classList.contains('task-list-item')) {
        return;
      }

      // Get the text content
      const text = li.textContent?.trim() || '';

      // Check if it starts with "DONE" (with : or space)
      if (text.match(/^DONE[:\s]/i)) {
        // Convert to task-list-item
        li.classList.add('task-list-item');

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-list-item-checkbox';
        checkbox.checked = true;
        checkbox.disabled = true;

        // Wrap remaining text in span with strikethrough
        const span = document.createElement('span');
        span.style.textDecoration = 'line-through';

        // Get the text without "DONE" prefix
        const remainingText = text.replace(/^DONE[:\s]\s*/i, '');
        span.textContent = remainingText;

        // Clear and rebuild the li
        li.innerHTML = '';
        li.appendChild(checkbox);
        li.appendChild(document.createTextNode(' '));
        li.appendChild(span);
      }
    });

    return div.innerHTML;
  }

  // Post-process HTML to add auth tokens to asset image URLs
  function addTokensToImages(html: string): string {
    if (!authToken) {
      return html;
    }

    const div = document.createElement('div');
    div.innerHTML = html;

    // Find all images that point to /assets/
    const images = div.querySelectorAll('img[src^="http://localhost:8000/assets/"], img[src^="/assets/"]');

    images.forEach(img => {
      const src = img.getAttribute('src');
      if (src && !src.includes('?token=')) {
        // Add token as query parameter
        const separator = src.includes('?') ? '&' : '?';
        img.setAttribute('src', `${src}${separator}token=${authToken}`);
      }
    });

    return div.innerHTML;
  }

  // Auth token management
  let authToken = localStorage.getItem('pkm-authToken');

  // Session management
  let sessionId = localStorage.getItem('pkm-sessionId') ||
                  'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  localStorage.setItem('pkm-sessionId', sessionId);

  // Model and thinking preferences
  let selectedModel = localStorage.getItem('pkm-model') || 'claude-haiku-4-5';
  let thinkingEnabled = localStorage.getItem('pkm-thinking') === 'true';

  // DOM elements
  const loginScreen = document.getElementById('login-screen')!;
  const appDiv = document.getElementById('app')!;
  const passwordInput = document.getElementById('password-input') as HTMLInputElement;
  const loginBtn = document.getElementById('login-btn') as HTMLButtonElement;
  const loginError = document.getElementById('login-error')!;
  const chat = document.getElementById('chat')!;
  const input = document.getElementById('input') as HTMLInputElement;
  const sendBtn = document.getElementById('send-btn') as HTMLButtonElement;
  const loading = document.getElementById('loading')!;
  const emptyState = document.getElementById('empty-state')!;
  const modelSelect = document.getElementById('model-select') as HTMLSelectElement;
  const thinkingToggle = document.getElementById('thinking-toggle') as HTMLInputElement;

  // Voice input
  let voiceInput: VoiceInput | null = null;
  let autoSendTimeout: number | null = null;

  // Handle login
  async function handleLogin(event: Event) {
    event.preventDefault();
    const password = passwordInput.value;

    loginBtn.disabled = true;
    loginError.classList.add('hidden');

    try {
      const res = await fetch('/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({password})
      });

      const data = await res.json();

      if (res.ok) {
        authToken = data.token;
        localStorage.setItem('pkm-authToken', authToken);
        showApp();
      } else {
        loginError.textContent = data.error || 'Invalid password';
        loginError.classList.remove('hidden');
        passwordInput.value = '';
        passwordInput.focus();
      }
    } catch (e: any) {
      loginError.textContent = 'Connection error: ' + e.message;
      loginError.classList.remove('hidden');
    } finally {
      loginBtn.disabled = false;
    }
  }

  // Initialize voice input
  function initializeVoiceInput() {
    const voiceBtn = document.getElementById('voice-btn') as HTMLButtonElement;
    const voiceStatus = document.getElementById('voice-status') as HTMLDivElement;
    const voiceStatusText = document.getElementById('voice-status-text') as HTMLSpanElement;

    if (!voiceBtn || !voiceStatus || !voiceStatusText) {
      console.warn('Voice input elements not found');
      return;
    }

    voiceInput = new VoiceInput({
      language: 'en-US',
      continuous: false,
      interimResults: true,

      onTranscript: (text: string, isFinal: boolean) => {
        if (isFinal) {
          // Append to textarea
          const currentText = input.value.trim();
          const separator = currentText ? ' ' : '';
          input.value = currentText + separator + text;
          autoResizeTextarea();
          voiceStatusText.textContent = 'Sending in 5 seconds... (edit to cancel)';

          // Set auto-send timeout
          if (autoSendTimeout) {
            clearTimeout(autoSendTimeout);
          }
          autoSendTimeout = window.setTimeout(() => {
            send();
            autoSendTimeout = null;
          }, 5000);
        } else {
          // Show interim in status
          voiceStatusText.textContent = `Listening: "${text}"`;
        }
      },

      onStart: () => {
        voiceBtn.classList.add('recording');
        voiceBtn.title = 'Tap to stop recording';
        voiceStatus.classList.remove('hidden');
        voiceStatusText.textContent = 'Listening...';
      },

      onEnd: () => {
        voiceBtn.classList.remove('recording');
        voiceBtn.title = 'Tap to start voice input';
        setTimeout(() => voiceStatus.classList.add('hidden'), 2000);
      },

      onError: (error: string) => {
        voiceBtn.classList.remove('recording');
        voiceStatusText.textContent = error;
        // Show error in red
        voiceStatus.classList.remove('bg-blue-50', 'border-blue-200', 'text-blue-700');
        voiceStatus.classList.add('bg-red-50', 'border-red-200', 'text-red-700');
        setTimeout(() => {
          voiceStatus.classList.add('hidden');
          // Reset colors
          voiceStatus.classList.add('bg-blue-50', 'border-blue-200', 'text-blue-700');
          voiceStatus.classList.remove('bg-red-50', 'border-red-200', 'text-red-700');
        }, 3000);
      }
    });

    // Check browser support
    if (!voiceInput.isSupported()) {
      voiceBtn.disabled = true;
      voiceBtn.classList.add('disabled');
      voiceBtn.title = 'Voice input not supported in this browser';
      return;
    }

    // Click handler
    voiceBtn.addEventListener('click', () => {
      if (!voiceInput) return;
      voiceInput.toggle();
    });
  }

  // Show app (hide login)
  function showApp() {
    loginScreen.classList.add('hidden');

    const appContainer = document.getElementById('app-container');
    if (appContainer) {
      appContainer.classList.remove('hidden');
    }

    // Initialize UI controls from saved preferences
    modelSelect.value = selectedModel;
    thinkingToggle.checked = thinkingEnabled;

    // Restore last active tab (default to chat)
    const savedTab = localStorage.getItem('pkm-currentTab') as 'chat' | 'editor' || 'chat';
    switchTab(savedTab);

    loadHistory();
    initializeVoiceInput();
  }

  // Show login (hide app)
  function showLogin() {
    loginScreen.classList.remove('hidden');

    const appContainer = document.getElementById('app-container');
    if (appContainer) {
      appContainer.classList.add('hidden');
    }

    passwordInput.value = '';
    passwordInput.focus();
  }

  // Logout
  function logout() {
    authToken = null;
    localStorage.removeItem('pkm-authToken');
    showLogin();
  }

  // Switch between tabs
  function switchTab(tab: 'chat' | 'editor') {
    const chatApp = document.getElementById('app');
    const editorApp = document.getElementById('editor-app');
    const chatTab = document.getElementById('chat-tab');
    const editorTab = document.getElementById('editor-tab');
    const editorHeaderStatus = document.getElementById('editor-header-status');

    if (tab === 'chat') {
      chatApp?.classList.remove('hidden');
      editorApp?.classList.add('hidden');
      editorHeaderStatus?.classList.add('hidden');
      editorHeaderStatus?.classList.remove('flex');

      chatTab?.classList.remove('bg-white/0');
      chatTab?.classList.add('bg-white/20');
      editorTab?.classList.remove('bg-white/20');
      editorTab?.classList.add('bg-white/0');

      // Scroll chat to bottom when switching to it
      setTimeout(() => {
        const chatDiv = document.getElementById('chat');
        if (chatDiv) {
          chatDiv.scrollTop = chatDiv.scrollHeight;
        }
      }, 0);

      input.focus();
    } else {
      chatApp?.classList.add('hidden');
      editorApp?.classList.remove('hidden');
      editorHeaderStatus?.classList.remove('hidden');
      editorHeaderStatus?.classList.add('flex');

      editorTab?.classList.remove('bg-white/0');
      editorTab?.classList.add('bg-white/20');
      chatTab?.classList.remove('bg-white/20');
      chatTab?.classList.add('bg-white/0');
    }

    // Save current tab preference
    localStorage.setItem('pkm-currentTab', tab);
  }

  // Update model selection
  function updateModel() {
    selectedModel = modelSelect.value;
    localStorage.setItem('pkm-model', selectedModel);
    console.log('Model changed to:', selectedModel);
  }

  // Update thinking toggle
  function updateThinking() {
    thinkingEnabled = thinkingToggle.checked;
    localStorage.setItem('pkm-thinking', thinkingEnabled.toString());
    console.log('Deep thinking:', thinkingEnabled);
  }

  // Verify token on page load
  async function verifyToken() {
    if (!authToken) {
      showLogin();
      return;
    }

    try {
      const res = await fetch('/verify-token', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({token: authToken})
      });

      const data = await res.json();

      if (data.valid) {
        showApp();
      } else {
        authToken = null;
        localStorage.removeItem('pkm-authToken');
        showLogin();
      }
    } catch (e) {
      console.error('Token verification error:', e);
      showLogin();
    }
  }

  // Get auth headers
  function getAuthHeaders(): HeadersInit {
    const headers: HeadersInit = {'Content-Type': 'application/json'};
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }
    return headers;
  }

  // Handle 401 errors
  function handle401() {
    authToken = null;
    localStorage.removeItem('pkm-authToken');
    showLogin();
    alert('Your session has expired. Please log in again.');
  }

  // Send message
  async function send() {
    // Clear auto-send timeout if active
    if (autoSendTimeout) {
      clearTimeout(autoSendTimeout);
      autoSendTimeout = null;

      // Hide voice status bar when auto-sending
      const voiceStatus = document.getElementById('voice-status');
      if (voiceStatus) {
        voiceStatus.classList.add('hidden');
      }
    }

    const message = input.value.trim();
    if (!message) return;

    input.value = '';
    input.style.height = 'auto'; // Reset textarea height
    input.disabled = true;
    sendBtn.disabled = true;

    emptyState.style.display = 'none';

    appendMessage('user', message);

    loading.classList.remove('hidden');
    loading.classList.add('flex');
    chat.scrollTop = chat.scrollHeight;

    try {
      // Get user's timezone from browser
      const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

      const requestBody: any = {
        message: message,
        session_id: sessionId,
        model: selectedModel,
        timezone: userTimezone
      };

      if (thinkingEnabled) {
        requestBody.thinking = { type: 'enabled', budget_tokens: 10000 };
      }

      const res = await fetch('/query', {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify(requestBody)
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const data = await res.json();

      loading.classList.add('hidden');
      loading.classList.remove('flex');

      appendMessage('assistant', data.response);
    } catch (e: any) {
      loading.classList.add('hidden');
      loading.classList.remove('flex');
      appendMessage('assistant', '‚ùå Error: ' + e.message);
    } finally {
      input.disabled = false;
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Send example query
  function sendExample(text: string) {
    input.value = text;
    send();
  }

  // Append message to chat
  function appendMessage(role: string, text: string) {
    const div = document.createElement('div');
    div.className = `message ${role}`;

    if (role === 'assistant') {
      let rendered = md.render(text);
      rendered = processDoneItems(rendered);
      rendered = addTokensToImages(rendered);
      div.innerHTML = rendered;
    } else {
      div.textContent = text;
    }

    chat.insertBefore(div, loading);
    chat.scrollTop = chat.scrollHeight;
  }

  // Show/hide model settings modal
  function showModelSettings() {
    const modal = document.getElementById('model-settings-modal')!;
    modal.classList.remove('hidden');
  }

  function hideModelSettings() {
    const modal = document.getElementById('model-settings-modal')!;
    modal.classList.add('hidden');
  }

  // Show session history modal
  async function showSessionHistory() {
    const modal = document.getElementById('session-history-modal')!;
    const sessionList = document.getElementById('session-list')!;

    modal.classList.remove('hidden');
    sessionList.innerHTML = '<div class="text-center text-gray-500 py-8">Loading sessions...</div>';

    try {
      const res = await fetch('/sessions', {
        headers: getAuthHeaders()
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const sessions = await res.json();

      if (sessions.length === 0) {
        sessionList.innerHTML = '<div class="text-center text-gray-500 py-8">No sessions found</div>';
        return;
      }

      // Sort by updated_at descending
      sessions.sort((a: any, b: any) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime());

      sessionList.innerHTML = sessions.map((session: any) => {
        const isActive = session.session_id === sessionId;
        const date = new Date(session.updated_at).toLocaleString();
        const preview = session.preview || 'Empty session';

        return `
          <div class="border rounded-lg p-4 mb-3 hover:bg-gray-50 cursor-pointer ${isActive ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}"
               onclick="switchToSession('${session.session_id}')">
            <div class="flex justify-between items-start mb-2">
              <div class="text-sm text-gray-500">${date}</div>
              ${isActive ? '<span class="text-xs px-2 py-1 bg-blue-500 text-white rounded">Current</span>' : ''}
            </div>
            <div class="text-gray-800 truncate mb-1">${preview}</div>
            <div class="text-xs text-gray-500">${session.message_count} messages</div>
          </div>
        `;
      }).join('');
    } catch (e: any) {
      sessionList.innerHTML = `<div class="text-center text-red-500 py-8">Error loading sessions: ${e.message}</div>`;
    }
  }

  // Hide session history modal
  function hideSessionHistory() {
    const modal = document.getElementById('session-history-modal')!;
    modal.classList.add('hidden');
  }

  // Switch to a different session
  async function switchToSession(newSessionId: string) {
    if (newSessionId === sessionId) {
      hideSessionHistory();
      return;
    }

    sessionId = newSessionId;
    localStorage.setItem('pkm-sessionId', sessionId);

    // Clear current chat
    const messages = chat.querySelectorAll('.message');
    messages.forEach(msg => msg.remove());

    // Load new session history
    await loadHistory();

    hideSessionHistory();
    console.log('Switched to session:', sessionId);
  }

  // Start new session
  function newSession() {
    sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem('pkm-sessionId', sessionId);

    const messages = chat.querySelectorAll('.message');
    messages.forEach(msg => msg.remove());

    emptyState.style.display = 'block';

    console.log('New session started:', sessionId);
  }

  // Load conversation history
  async function loadHistory() {
    try {
      const res = await fetch(`/sessions/${sessionId}/history`, {
        headers: getAuthHeaders()
      });

      if (res.status === 401) {
        handle401();
        return;
      }

      const history = await res.json();

      if (history.length > 0) {
        emptyState.style.display = 'none';
        history.forEach((msg: any) => appendMessage(msg.role, msg.text));
      }
    } catch (e) {
      console.error('Error loading history:', e);
    }
  }

  // Auto-resize textarea as user types
  function autoResizeTextarea() {
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }

  input.addEventListener('input', () => {
    autoResizeTextarea();

    // Clear auto-send timeout when user edits
    if (autoSendTimeout) {
      clearTimeout(autoSendTimeout);
      autoSendTimeout = null;

      // Hide the voice status bar if showing auto-send message
      const voiceStatus = document.getElementById('voice-status');
      if (voiceStatus && !voiceStatus.classList.contains('hidden')) {
        voiceStatus.classList.add('hidden');
      }
    }
  });

  // Keyboard shortcuts
  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      input.focus();
    }
  });

  // Set up login form handler
  document.getElementById('login-form')?.addEventListener('submit', handleLogin);

  // Swipe gesture handling for mobile tab switching
  let touchStartX = 0;
  let touchStartY = 0;
  let touchEndX = 0;
  let touchEndY = 0;
  let touchStartElement: HTMLElement | null = null;

  function isSwipeableArea(element: HTMLElement | null): boolean {
    if (!element) return false;

    // Check if touch started in chat messages area
    const chatArea = document.getElementById('chat');
    if (chatArea && chatArea.contains(element)) {
      return true;
    }

    // Check if touch started in editor file selector area (top bar of editor)
    const editorFileSelector = element.closest('.bg-gray-50.px-4.py-3.border-b');
    if (editorFileSelector) {
      return true;
    }

    // Check if touch is in the header area
    const header = element.closest('.bg-blue-500.text-white');
    if (header) {
      return true;
    }

    return false;
  }

  function handleSwipeGesture() {
    // Only handle swipes that started in swipeable areas
    if (!isSwipeableArea(touchStartElement)) {
      return;
    }

    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;

    // Only handle horizontal swipes (more horizontal than vertical)
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      const minSwipeDistance = 50; // minimum distance for swipe

      if (deltaX < -minSwipeDistance) {
        // Swipe left - go to editor
        switchTab('editor');
      } else if (deltaX > minSwipeDistance) {
        // Swipe right - go to chat
        switchTab('chat');
      }
    }
  }

  // Add touch listeners to content area
  const contentArea = document.querySelector('#app-container');
  if (contentArea) {
    contentArea.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
      touchStartElement = e.target as HTMLElement;
    }, { passive: true });

    contentArea.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      handleSwipeGesture();
      touchStartElement = null;
    }, { passive: true });
  }

  // Verify token and load app on page load
  verifyToken();

  // Make functions globally available
  (window as any).send = send;
  (window as any).sendExample = sendExample;
  (window as any).showModelSettings = showModelSettings;
  (window as any).hideModelSettings = hideModelSettings;
  (window as any).showSessionHistory = showSessionHistory;
  (window as any).hideSessionHistory = hideSessionHistory;
  (window as any).switchToSession = switchToSession;
  (window as any).newSession = newSession;
  (window as any).logout = logout;
  (window as any).updateModel = updateModel;
  (window as any).updateThinking = updateThinking;
  (window as any).switchTab = switchTab;

  // Make sessionId available globally for SSE connection
  (window as any).getSessionId = () => sessionId;
</script>
